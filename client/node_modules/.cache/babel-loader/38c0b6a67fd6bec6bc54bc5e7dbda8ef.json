{"ast":null,"code":"\"use strict\";\n\nexports.__esModule = true;\n\nvar parser_1 = require(\"@babel/parser\");\n\nvar b = require(\"@babel/types\");\n\nvar binaryOperation_1 = require(\"./binaryOperation\");\n\nfunction expressionToConstant(expression, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var constant = true;\n\n  function toConstant(expression) {\n    if (!constant) return;\n\n    if (b.isArrayExpression(expression)) {\n      var result_1 = [];\n\n      for (var i = 0; constant && i < expression.elements.length; i++) {\n        var element = expression.elements[i];\n\n        if (b.isSpreadElement(element)) {\n          var spread = toConstant(element.argument);\n\n          if (!(isSpreadable(spread) && constant)) {\n            constant = false;\n          } else {\n            result_1.push.apply(result_1, spread);\n          }\n        } else if (b.isExpression(element)) {\n          result_1.push(toConstant(element));\n        } else {\n          constant = false;\n        }\n      }\n\n      return result_1;\n    }\n\n    if (b.isBinaryExpression(expression)) {\n      var left = toConstant(expression.left);\n      var right = toConstant(expression.right);\n      return constant && binaryOperation_1[\"default\"](expression.operator, left, right);\n    }\n\n    if (b.isBooleanLiteral(expression)) {\n      return expression.value;\n    }\n\n    if (b.isCallExpression(expression)) {\n      var args = [];\n\n      for (var i = 0; constant && i < expression.arguments.length; i++) {\n        var arg = expression.arguments[i];\n\n        if (b.isSpreadElement(arg)) {\n          var spread = toConstant(arg.argument);\n\n          if (!(isSpreadable(spread) && constant)) {\n            constant = false;\n          } else {\n            args.push.apply(args, spread);\n          }\n        } else if (b.isExpression(arg)) {\n          args.push(toConstant(arg));\n        } else {\n          constant = false;\n        }\n      }\n\n      if (!constant) return;\n\n      if (b.isMemberExpression(expression.callee)) {\n        var object = toConstant(expression.callee.object);\n\n        if (!object || !constant) {\n          constant = false;\n          return;\n        }\n\n        var member = expression.callee.computed ? toConstant(expression.callee.property) : b.isIdentifier(expression.callee.property) ? expression.callee.property.name : undefined;\n\n        if (member === undefined && !expression.callee.computed) {\n          constant = false;\n        }\n\n        if (!constant) return;\n\n        if (canCallMethod(object, '' + member)) {\n          return object[member].apply(object, args);\n        }\n      } else {\n        if (!b.isExpression(expression.callee)) {\n          constant = false;\n          return;\n        }\n\n        var callee = toConstant(expression.callee);\n        if (!constant) return;\n        return callee.apply(null, args);\n      }\n    }\n\n    if (b.isConditionalExpression(expression)) {\n      var test = toConstant(expression.test);\n      return test ? toConstant(expression.consequent) : toConstant(expression.alternate);\n    }\n\n    if (b.isIdentifier(expression)) {\n      if (options.constants && {}.hasOwnProperty.call(options.constants, expression.name)) {\n        return options.constants[expression.name];\n      }\n    }\n\n    if (b.isLogicalExpression(expression)) {\n      var left = toConstant(expression.left);\n      var right = toConstant(expression.right);\n\n      if (constant && expression.operator === '&&') {\n        return left && right;\n      }\n\n      if (constant && expression.operator === '||') {\n        return left || right;\n      }\n    }\n\n    if (b.isMemberExpression(expression)) {\n      var object = toConstant(expression.object);\n\n      if (!object || !constant) {\n        constant = false;\n        return;\n      }\n\n      var member = expression.computed ? toConstant(expression.property) : b.isIdentifier(expression.property) ? expression.property.name : undefined;\n\n      if (member === undefined && !expression.computed) {\n        constant = false;\n      }\n\n      if (!constant) return;\n\n      if ({}.hasOwnProperty.call(object, '' + member) && member[0] !== '_') {\n        return object[member];\n      }\n    }\n\n    if (b.isNullLiteral(expression)) {\n      return null;\n    }\n\n    if (b.isNumericLiteral(expression)) {\n      return expression.value;\n    }\n\n    if (b.isObjectExpression(expression)) {\n      var result_2 = {};\n\n      for (var i = 0; constant && i < expression.properties.length; i++) {\n        var property = expression.properties[i];\n\n        if (b.isObjectProperty(property)) {\n          if (property.shorthand) {\n            constant = false;\n            return;\n          }\n\n          var key = property.computed ? toConstant(property.key) : b.isIdentifier(property.key) ? property.key.name : b.isStringLiteral(property.key) ? property.key.value : undefined;\n\n          if (!key || key[0] === '_') {\n            constant = false;\n          }\n\n          if (!constant) return;\n\n          if (b.isExpression(property.value)) {\n            var value = toConstant(property.value);\n            if (!constant) return;\n            result_2[key] = value;\n          } else {\n            constant = false;\n          }\n        } else if (b.isObjectMethod(property)) {\n          constant = false;\n        } else if (b.isSpreadProperty(property)) {\n          var argument = toConstant(property.argument);\n          if (!argument) constant = false;\n          if (!constant) return;\n          Object.assign(result_2, argument);\n        }\n      }\n\n      return result_2;\n    }\n\n    if (b.isParenthesizedExpression(expression)) {\n      return toConstant(expression.expression);\n    }\n\n    if (b.isRegExpLiteral(expression)) {\n      return new RegExp(expression.pattern, expression.flags);\n    }\n\n    if (b.isSequenceExpression(expression)) {\n      for (var i = 0; i < expression.expressions.length - 1 && constant; i++) {\n        toConstant(expression.expressions[i]);\n      }\n\n      return toConstant(expression.expressions[expression.expressions.length - 1]);\n    }\n\n    if (b.isStringLiteral(expression)) {\n      return expression.value;\n    } // TODO: TaggedTemplateExpression\n\n\n    if (b.isTemplateLiteral(expression)) {\n      var result_3 = '';\n\n      for (var i = 0; i < expression.quasis.length; i++) {\n        var quasi = expression.quasis[i];\n        result_3 += quasi.value.cooked;\n\n        if (i < expression.expressions.length) {\n          result_3 += '' + toConstant(expression.expressions[i]);\n        }\n      }\n\n      return result_3;\n    }\n\n    if (b.isUnaryExpression(expression)) {\n      var argument = toConstant(expression.argument);\n\n      if (!constant) {\n        return;\n      }\n\n      switch (expression.operator) {\n        case '-':\n          return -argument;\n\n        case '+':\n          return +argument;\n\n        case '!':\n          return !argument;\n\n        case '~':\n          return ~argument;\n\n        case 'typeof':\n          return typeof argument;\n\n        case 'void':\n          return void argument;\n      }\n    }\n\n    constant = false;\n  }\n\n  var result = toConstant(expression);\n  return constant ? {\n    constant: true,\n    result: result\n  } : {\n    constant: false\n  };\n}\n\nexports.expressionToConstant = expressionToConstant;\n\nfunction isSpreadable(value) {\n  return typeof value === 'string' || Array.isArray(value) || typeof Set !== 'undefined' && value instanceof Set || typeof Map !== 'undefined' && value instanceof Map;\n}\n\nfunction shallowEqual(a, b) {\n  if (a === b) return true;\n\n  if (a && b && typeof a === 'object' && typeof b === 'object') {\n    for (var key in a) {\n      if (a[key] !== b[key]) {\n        return false;\n      }\n    }\n\n    for (var key in b) {\n      if (a[key] !== b[key]) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  return false;\n}\n\nfunction canCallMethod(object, member) {\n  switch (typeof object) {\n    case 'boolean':\n      switch (member) {\n        case 'toString':\n          return true;\n\n        default:\n          return false;\n      }\n\n    case 'number':\n      switch (member) {\n        case 'toExponential':\n        case 'toFixed':\n        case 'toPrecision':\n        case 'toString':\n          return true;\n\n        default:\n          return false;\n      }\n\n    case 'string':\n      switch (member) {\n        case 'charAt':\n        case 'charCodeAt':\n        case 'codePointAt':\n        case 'concat':\n        case 'endsWith':\n        case 'includes':\n        case 'indexOf':\n        case 'lastIndexOf':\n        case 'match':\n        case 'normalize':\n        case 'padEnd':\n        case 'padStart':\n        case 'repeat':\n        case 'replace':\n        case 'search':\n        case 'slice':\n        case 'split':\n        case 'startsWith':\n        case 'substr':\n        case 'substring':\n        case 'toLowerCase':\n        case 'toUpperCase':\n        case 'trim':\n          return true;\n\n        default:\n          return false;\n      }\n\n    default:\n      if (object instanceof RegExp) {\n        switch (member) {\n          case 'test':\n          case 'exec':\n            return true;\n\n          default:\n            return false;\n        }\n      }\n\n      return {}.hasOwnProperty.call(object, member) && member[0] !== '_';\n  }\n}\n\nvar EMPTY_OBJECT = {};\nvar lastSrc = '';\nvar lastConstants = EMPTY_OBJECT;\nvar lastOptions = EMPTY_OBJECT;\nvar lastResult = null;\nvar lastWasConstant = false;\n\nfunction isConstant(src, constants, options) {\n  if (constants === void 0) {\n    constants = EMPTY_OBJECT;\n  }\n\n  if (options === void 0) {\n    options = EMPTY_OBJECT;\n  }\n\n  if (lastSrc === src && shallowEqual(lastConstants, constants) && shallowEqual(lastOptions, options)) {\n    return lastWasConstant;\n  }\n\n  lastSrc = src;\n  lastConstants = constants;\n  var ast;\n\n  try {\n    ast = parser_1.parseExpression(src, options);\n  } catch (ex) {\n    return lastWasConstant = false;\n  }\n\n  var _a = expressionToConstant(ast, {\n    constants: constants\n  }),\n      result = _a.result,\n      constant = _a.constant;\n\n  lastResult = result;\n  return lastWasConstant = constant;\n}\n\nexports.isConstant = isConstant;\n\nfunction toConstant(src, constants, options) {\n  if (constants === void 0) {\n    constants = EMPTY_OBJECT;\n  }\n\n  if (options === void 0) {\n    options = EMPTY_OBJECT;\n  }\n\n  if (!isConstant(src, constants, options)) {\n    throw new Error(JSON.stringify(src) + ' is not constant.');\n  }\n\n  return lastResult;\n}\n\nexports.toConstant = toConstant;\nexports[\"default\"] = isConstant;\nmodule.exports = isConstant;\nmodule.exports[\"default\"] = isConstant;\nmodule.exports.expressionToConstant = expressionToConstant;\nmodule.exports.isConstant = isConstant;\nmodule.exports.toConstant = toConstant;","map":{"version":3,"sources":["C:/Users/bekke/Documents/Art Website/node_modules/constantinople/lib/index.js"],"names":["exports","__esModule","parser_1","require","b","binaryOperation_1","expressionToConstant","expression","options","constant","toConstant","isArrayExpression","result_1","i","elements","length","element","isSpreadElement","spread","argument","isSpreadable","push","apply","isExpression","isBinaryExpression","left","right","operator","isBooleanLiteral","value","isCallExpression","args","arguments","arg","isMemberExpression","callee","object","member","computed","property","isIdentifier","name","undefined","canCallMethod","isConditionalExpression","test","consequent","alternate","constants","hasOwnProperty","call","isLogicalExpression","isNullLiteral","isNumericLiteral","isObjectExpression","result_2","properties","isObjectProperty","shorthand","key","isStringLiteral","isObjectMethod","isSpreadProperty","Object","assign","isParenthesizedExpression","isRegExpLiteral","RegExp","pattern","flags","isSequenceExpression","expressions","isTemplateLiteral","result_3","quasis","quasi","cooked","isUnaryExpression","result","Array","isArray","Set","Map","shallowEqual","a","EMPTY_OBJECT","lastSrc","lastConstants","lastOptions","lastResult","lastWasConstant","isConstant","src","ast","parseExpression","ex","_a","Error","JSON","stringify","module"],"mappings":"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","sourcesContent":["\"use strict\";\nexports.__esModule = true;\nvar parser_1 = require(\"@babel/parser\");\nvar b = require(\"@babel/types\");\nvar binaryOperation_1 = require(\"./binaryOperation\");\nfunction expressionToConstant(expression, options) {\n    if (options === void 0) { options = {}; }\n    var constant = true;\n    function toConstant(expression) {\n        if (!constant)\n            return;\n        if (b.isArrayExpression(expression)) {\n            var result_1 = [];\n            for (var i = 0; constant && i < expression.elements.length; i++) {\n                var element = expression.elements[i];\n                if (b.isSpreadElement(element)) {\n                    var spread = toConstant(element.argument);\n                    if (!(isSpreadable(spread) && constant)) {\n                        constant = false;\n                    }\n                    else {\n                        result_1.push.apply(result_1, spread);\n                    }\n                }\n                else if (b.isExpression(element)) {\n                    result_1.push(toConstant(element));\n                }\n                else {\n                    constant = false;\n                }\n            }\n            return result_1;\n        }\n        if (b.isBinaryExpression(expression)) {\n            var left = toConstant(expression.left);\n            var right = toConstant(expression.right);\n            return constant && binaryOperation_1[\"default\"](expression.operator, left, right);\n        }\n        if (b.isBooleanLiteral(expression)) {\n            return expression.value;\n        }\n        if (b.isCallExpression(expression)) {\n            var args = [];\n            for (var i = 0; constant && i < expression.arguments.length; i++) {\n                var arg = expression.arguments[i];\n                if (b.isSpreadElement(arg)) {\n                    var spread = toConstant(arg.argument);\n                    if (!(isSpreadable(spread) && constant)) {\n                        constant = false;\n                    }\n                    else {\n                        args.push.apply(args, spread);\n                    }\n                }\n                else if (b.isExpression(arg)) {\n                    args.push(toConstant(arg));\n                }\n                else {\n                    constant = false;\n                }\n            }\n            if (!constant)\n                return;\n            if (b.isMemberExpression(expression.callee)) {\n                var object = toConstant(expression.callee.object);\n                if (!object || !constant) {\n                    constant = false;\n                    return;\n                }\n                var member = expression.callee.computed\n                    ? toConstant(expression.callee.property)\n                    : b.isIdentifier(expression.callee.property)\n                        ? expression.callee.property.name\n                        : undefined;\n                if (member === undefined && !expression.callee.computed) {\n                    constant = false;\n                }\n                if (!constant)\n                    return;\n                if (canCallMethod(object, '' + member)) {\n                    return object[member].apply(object, args);\n                }\n            }\n            else {\n                if (!b.isExpression(expression.callee)) {\n                    constant = false;\n                    return;\n                }\n                var callee = toConstant(expression.callee);\n                if (!constant)\n                    return;\n                return callee.apply(null, args);\n            }\n        }\n        if (b.isConditionalExpression(expression)) {\n            var test = toConstant(expression.test);\n            return test\n                ? toConstant(expression.consequent)\n                : toConstant(expression.alternate);\n        }\n        if (b.isIdentifier(expression)) {\n            if (options.constants &&\n                {}.hasOwnProperty.call(options.constants, expression.name)) {\n                return options.constants[expression.name];\n            }\n        }\n        if (b.isLogicalExpression(expression)) {\n            var left = toConstant(expression.left);\n            var right = toConstant(expression.right);\n            if (constant && expression.operator === '&&') {\n                return left && right;\n            }\n            if (constant && expression.operator === '||') {\n                return left || right;\n            }\n        }\n        if (b.isMemberExpression(expression)) {\n            var object = toConstant(expression.object);\n            if (!object || !constant) {\n                constant = false;\n                return;\n            }\n            var member = expression.computed\n                ? toConstant(expression.property)\n                : b.isIdentifier(expression.property)\n                    ? expression.property.name\n                    : undefined;\n            if (member === undefined && !expression.computed) {\n                constant = false;\n            }\n            if (!constant)\n                return;\n            if ({}.hasOwnProperty.call(object, '' + member) && member[0] !== '_') {\n                return object[member];\n            }\n        }\n        if (b.isNullLiteral(expression)) {\n            return null;\n        }\n        if (b.isNumericLiteral(expression)) {\n            return expression.value;\n        }\n        if (b.isObjectExpression(expression)) {\n            var result_2 = {};\n            for (var i = 0; constant && i < expression.properties.length; i++) {\n                var property = expression.properties[i];\n                if (b.isObjectProperty(property)) {\n                    if (property.shorthand) {\n                        constant = false;\n                        return;\n                    }\n                    var key = property.computed\n                        ? toConstant(property.key)\n                        : b.isIdentifier(property.key)\n                            ? property.key.name\n                            : b.isStringLiteral(property.key)\n                                ? property.key.value\n                                : undefined;\n                    if (!key || key[0] === '_') {\n                        constant = false;\n                    }\n                    if (!constant)\n                        return;\n                    if (b.isExpression(property.value)) {\n                        var value = toConstant(property.value);\n                        if (!constant)\n                            return;\n                        result_2[key] = value;\n                    }\n                    else {\n                        constant = false;\n                    }\n                }\n                else if (b.isObjectMethod(property)) {\n                    constant = false;\n                }\n                else if (b.isSpreadProperty(property)) {\n                    var argument = toConstant(property.argument);\n                    if (!argument)\n                        constant = false;\n                    if (!constant)\n                        return;\n                    Object.assign(result_2, argument);\n                }\n            }\n            return result_2;\n        }\n        if (b.isParenthesizedExpression(expression)) {\n            return toConstant(expression.expression);\n        }\n        if (b.isRegExpLiteral(expression)) {\n            return new RegExp(expression.pattern, expression.flags);\n        }\n        if (b.isSequenceExpression(expression)) {\n            for (var i = 0; i < expression.expressions.length - 1 && constant; i++) {\n                toConstant(expression.expressions[i]);\n            }\n            return toConstant(expression.expressions[expression.expressions.length - 1]);\n        }\n        if (b.isStringLiteral(expression)) {\n            return expression.value;\n        }\n        // TODO: TaggedTemplateExpression\n        if (b.isTemplateLiteral(expression)) {\n            var result_3 = '';\n            for (var i = 0; i < expression.quasis.length; i++) {\n                var quasi = expression.quasis[i];\n                result_3 += quasi.value.cooked;\n                if (i < expression.expressions.length) {\n                    result_3 += '' + toConstant(expression.expressions[i]);\n                }\n            }\n            return result_3;\n        }\n        if (b.isUnaryExpression(expression)) {\n            var argument = toConstant(expression.argument);\n            if (!constant) {\n                return;\n            }\n            switch (expression.operator) {\n                case '-':\n                    return -argument;\n                case '+':\n                    return +argument;\n                case '!':\n                    return !argument;\n                case '~':\n                    return ~argument;\n                case 'typeof':\n                    return typeof argument;\n                case 'void':\n                    return void argument;\n            }\n        }\n        constant = false;\n    }\n    var result = toConstant(expression);\n    return constant ? { constant: true, result: result } : { constant: false };\n}\nexports.expressionToConstant = expressionToConstant;\nfunction isSpreadable(value) {\n    return (typeof value === 'string' ||\n        Array.isArray(value) ||\n        (typeof Set !== 'undefined' && value instanceof Set) ||\n        (typeof Map !== 'undefined' && value instanceof Map));\n}\nfunction shallowEqual(a, b) {\n    if (a === b)\n        return true;\n    if (a && b && typeof a === 'object' && typeof b === 'object') {\n        for (var key in a) {\n            if (a[key] !== b[key]) {\n                return false;\n            }\n        }\n        for (var key in b) {\n            if (a[key] !== b[key]) {\n                return false;\n            }\n        }\n        return true;\n    }\n    return false;\n}\nfunction canCallMethod(object, member) {\n    switch (typeof object) {\n        case 'boolean':\n            switch (member) {\n                case 'toString':\n                    return true;\n                default:\n                    return false;\n            }\n        case 'number':\n            switch (member) {\n                case 'toExponential':\n                case 'toFixed':\n                case 'toPrecision':\n                case 'toString':\n                    return true;\n                default:\n                    return false;\n            }\n        case 'string':\n            switch (member) {\n                case 'charAt':\n                case 'charCodeAt':\n                case 'codePointAt':\n                case 'concat':\n                case 'endsWith':\n                case 'includes':\n                case 'indexOf':\n                case 'lastIndexOf':\n                case 'match':\n                case 'normalize':\n                case 'padEnd':\n                case 'padStart':\n                case 'repeat':\n                case 'replace':\n                case 'search':\n                case 'slice':\n                case 'split':\n                case 'startsWith':\n                case 'substr':\n                case 'substring':\n                case 'toLowerCase':\n                case 'toUpperCase':\n                case 'trim':\n                    return true;\n                default:\n                    return false;\n            }\n        default:\n            if (object instanceof RegExp) {\n                switch (member) {\n                    case 'test':\n                    case 'exec':\n                        return true;\n                    default:\n                        return false;\n                }\n            }\n            return {}.hasOwnProperty.call(object, member) && member[0] !== '_';\n    }\n}\nvar EMPTY_OBJECT = {};\nvar lastSrc = '';\nvar lastConstants = EMPTY_OBJECT;\nvar lastOptions = EMPTY_OBJECT;\nvar lastResult = null;\nvar lastWasConstant = false;\nfunction isConstant(src, constants, options) {\n    if (constants === void 0) { constants = EMPTY_OBJECT; }\n    if (options === void 0) { options = EMPTY_OBJECT; }\n    if (lastSrc === src &&\n        shallowEqual(lastConstants, constants) &&\n        shallowEqual(lastOptions, options)) {\n        return lastWasConstant;\n    }\n    lastSrc = src;\n    lastConstants = constants;\n    var ast;\n    try {\n        ast = parser_1.parseExpression(src, options);\n    }\n    catch (ex) {\n        return (lastWasConstant = false);\n    }\n    var _a = expressionToConstant(ast, { constants: constants }), result = _a.result, constant = _a.constant;\n    lastResult = result;\n    return (lastWasConstant = constant);\n}\nexports.isConstant = isConstant;\nfunction toConstant(src, constants, options) {\n    if (constants === void 0) { constants = EMPTY_OBJECT; }\n    if (options === void 0) { options = EMPTY_OBJECT; }\n    if (!isConstant(src, constants, options)) {\n        throw new Error(JSON.stringify(src) + ' is not constant.');\n    }\n    return lastResult;\n}\nexports.toConstant = toConstant;\nexports[\"default\"] = isConstant;\nmodule.exports = isConstant;\nmodule.exports[\"default\"] = isConstant;\nmodule.exports.expressionToConstant = expressionToConstant;\nmodule.exports.isConstant = isConstant;\nmodule.exports.toConstant = toConstant;\n"]},"metadata":{},"sourceType":"script"}