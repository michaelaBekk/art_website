{"ast":null,"code":"'use strict';\n\nvar fs = require('fs');\n\nvar path = require('path');\n\nvar walk = require('pug-walk');\n\nvar assign = require('object-assign');\n\nmodule.exports = load;\n\nfunction load(ast, options) {\n  options = getOptions(options); // clone the ast\n\n  ast = JSON.parse(JSON.stringify(ast));\n  return walk(ast, function (node) {\n    if (node.str === undefined) {\n      if (node.type === 'Include' || node.type === 'RawInclude' || node.type === 'Extends') {\n        var file = node.file;\n\n        if (file.type !== 'FileReference') {\n          throw new Error('Expected file.type to be \"FileReference\"');\n        }\n\n        var path, str, raw;\n\n        try {\n          path = options.resolve(file.path, file.filename, options);\n          file.fullPath = path;\n          raw = options.read(path, options);\n          str = raw.toString('utf8');\n        } catch (ex) {\n          ex.message += '\\n    at ' + node.filename + ' line ' + node.line;\n          throw ex;\n        }\n\n        file.str = str;\n        file.raw = raw;\n\n        if (node.type === 'Extends' || node.type === 'Include') {\n          file.ast = load.string(str, assign({}, options, {\n            filename: path\n          }));\n        }\n      }\n    }\n  });\n}\n\nload.string = function loadString(src, options) {\n  options = assign(getOptions(options), {\n    src: src\n  });\n  var tokens = options.lex(src, options);\n  var ast = options.parse(tokens, options);\n  return load(ast, options);\n};\n\nload.file = function loadFile(filename, options) {\n  options = assign(getOptions(options), {\n    filename: filename\n  });\n  var str = options.read(filename).toString('utf8');\n  return load.string(str, options);\n};\n\nload.resolve = function resolve(filename, source, options) {\n  filename = filename.trim();\n  if (filename[0] !== '/' && !source) throw new Error('the \"filename\" option is required to use includes and extends with \"relative\" paths');\n  if (filename[0] === '/' && !options.basedir) throw new Error('the \"basedir\" option is required to use includes and extends with \"absolute\" paths');\n  filename = path.join(filename[0] === '/' ? options.basedir : path.dirname(source.trim()), filename);\n  return filename;\n};\n\nload.read = function read(filename, options) {\n  return fs.readFileSync(filename);\n};\n\nload.validateOptions = function validateOptions(options) {\n  /* istanbul ignore if */\n  if (typeof options !== 'object') {\n    throw new TypeError('options must be an object');\n  }\n  /* istanbul ignore if */\n\n\n  if (typeof options.lex !== 'function') {\n    throw new TypeError('options.lex must be a function');\n  }\n  /* istanbul ignore if */\n\n\n  if (typeof options.parse !== 'function') {\n    throw new TypeError('options.parse must be a function');\n  }\n  /* istanbul ignore if */\n\n\n  if (options.resolve && typeof options.resolve !== 'function') {\n    throw new TypeError('options.resolve must be a function');\n  }\n  /* istanbul ignore if */\n\n\n  if (options.read && typeof options.read !== 'function') {\n    throw new TypeError('options.read must be a function');\n  }\n};\n\nfunction getOptions(options) {\n  load.validateOptions(options);\n  return assign({\n    resolve: load.resolve,\n    read: load.read\n  }, options);\n}","map":{"version":3,"sources":["C:/Users/bekke/Documents/Art Website/node_modules/pug-load/index.js"],"names":["fs","require","path","walk","assign","module","exports","load","ast","options","getOptions","JSON","parse","stringify","node","str","undefined","type","file","Error","raw","resolve","filename","fullPath","read","toString","ex","message","line","string","loadString","src","tokens","lex","loadFile","source","trim","basedir","join","dirname","readFileSync","validateOptions","TypeError"],"mappings":"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","sourcesContent":["'use strict';\n\nvar fs = require('fs');\nvar path = require('path');\nvar walk = require('pug-walk');\nvar assign = require('object-assign');\n\nmodule.exports = load;\nfunction load(ast, options) {\n  options = getOptions(options);\n  // clone the ast\n  ast = JSON.parse(JSON.stringify(ast));\n  return walk(ast, function(node) {\n    if (node.str === undefined) {\n      if (\n        node.type === 'Include' ||\n        node.type === 'RawInclude' ||\n        node.type === 'Extends'\n      ) {\n        var file = node.file;\n        if (file.type !== 'FileReference') {\n          throw new Error('Expected file.type to be \"FileReference\"');\n        }\n        var path, str, raw;\n        try {\n          path = options.resolve(file.path, file.filename, options);\n          file.fullPath = path;\n          raw = options.read(path, options);\n          str = raw.toString('utf8');\n        } catch (ex) {\n          ex.message += '\\n    at ' + node.filename + ' line ' + node.line;\n          throw ex;\n        }\n        file.str = str;\n        file.raw = raw;\n        if (node.type === 'Extends' || node.type === 'Include') {\n          file.ast = load.string(\n            str,\n            assign({}, options, {\n              filename: path,\n            })\n          );\n        }\n      }\n    }\n  });\n}\n\nload.string = function loadString(src, options) {\n  options = assign(getOptions(options), {\n    src: src,\n  });\n  var tokens = options.lex(src, options);\n  var ast = options.parse(tokens, options);\n  return load(ast, options);\n};\nload.file = function loadFile(filename, options) {\n  options = assign(getOptions(options), {\n    filename: filename,\n  });\n  var str = options.read(filename).toString('utf8');\n  return load.string(str, options);\n};\n\nload.resolve = function resolve(filename, source, options) {\n  filename = filename.trim();\n  if (filename[0] !== '/' && !source)\n    throw new Error(\n      'the \"filename\" option is required to use includes and extends with \"relative\" paths'\n    );\n\n  if (filename[0] === '/' && !options.basedir)\n    throw new Error(\n      'the \"basedir\" option is required to use includes and extends with \"absolute\" paths'\n    );\n\n  filename = path.join(\n    filename[0] === '/' ? options.basedir : path.dirname(source.trim()),\n    filename\n  );\n\n  return filename;\n};\nload.read = function read(filename, options) {\n  return fs.readFileSync(filename);\n};\n\nload.validateOptions = function validateOptions(options) {\n  /* istanbul ignore if */\n  if (typeof options !== 'object') {\n    throw new TypeError('options must be an object');\n  }\n  /* istanbul ignore if */\n  if (typeof options.lex !== 'function') {\n    throw new TypeError('options.lex must be a function');\n  }\n  /* istanbul ignore if */\n  if (typeof options.parse !== 'function') {\n    throw new TypeError('options.parse must be a function');\n  }\n  /* istanbul ignore if */\n  if (options.resolve && typeof options.resolve !== 'function') {\n    throw new TypeError('options.resolve must be a function');\n  }\n  /* istanbul ignore if */\n  if (options.read && typeof options.read !== 'function') {\n    throw new TypeError('options.read must be a function');\n  }\n};\n\nfunction getOptions(options) {\n  load.validateOptions(options);\n  return assign(\n    {\n      resolve: load.resolve,\n      read: load.read,\n    },\n    options\n  );\n}\n"]},"metadata":{},"sourceType":"script"}