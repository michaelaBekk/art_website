{"ast":null,"code":"'use strict';\n\nvar error = require('pug-error');\n\nmodule.exports = stripComments;\n\nfunction unexpectedToken(type, occasion, filename, line) {\n  var msg = '`' + type + '` encountered when ' + occasion;\n  throw error('UNEXPECTED_TOKEN', msg, {\n    filename: filename,\n    line: line\n  });\n}\n\nfunction stripComments(input, options) {\n  options = options || {}; // Default: strip unbuffered comments and leave buffered ones alone\n\n  var stripUnbuffered = options.stripUnbuffered !== false;\n  var stripBuffered = options.stripBuffered === true;\n  var filename = options.filename;\n  var out = []; // If we have encountered a comment token and are not sure if we have gotten\n  // out of the comment or not\n\n  var inComment = false; // If we are sure that we are in a block comment and all tokens except\n  // `end-pipeless-text` should be ignored\n\n  var inPipelessText = false;\n  return input.filter(function (tok) {\n    switch (tok.type) {\n      case 'comment':\n        if (inComment) {\n          unexpectedToken('comment', 'already in a comment', filename, tok.line);\n        } else {\n          inComment = tok.buffer ? stripBuffered : stripUnbuffered;\n          return !inComment;\n        }\n\n      case 'start-pipeless-text':\n        if (!inComment) return true;\n\n        if (inPipelessText) {\n          unexpectedToken('start-pipeless-text', 'already in pipeless text mode', filename, tok.line);\n        }\n\n        inPipelessText = true;\n        return false;\n\n      case 'end-pipeless-text':\n        if (!inComment) return true;\n\n        if (!inPipelessText) {\n          unexpectedToken('end-pipeless-text', 'not in pipeless text mode', filename, tok.line);\n        }\n\n        inPipelessText = false;\n        inComment = false;\n        return false;\n      // There might be a `text` right after `comment` but before\n      // `start-pipeless-text`. Treat it accordingly.\n\n      case 'text':\n        return !inComment;\n\n      default:\n        if (inPipelessText) return false;\n        inComment = false;\n        return true;\n    }\n  });\n}","map":{"version":3,"sources":["C:/Users/bekke/Documents/Art Website/node_modules/pug-strip-comments/index.js"],"names":["error","require","module","exports","stripComments","unexpectedToken","type","occasion","filename","line","msg","input","options","stripUnbuffered","stripBuffered","out","inComment","inPipelessText","filter","tok","buffer"],"mappings":"AAAA;;AAEA,IAAIA,KAAK,GAAGC,OAAO,CAAC,WAAD,CAAnB;;AAEAC,MAAM,CAACC,OAAP,GAAiBC,aAAjB;;AAEA,SAASC,eAAT,CAAyBC,IAAzB,EAA+BC,QAA/B,EAAyCC,QAAzC,EAAmDC,IAAnD,EAAyD;AACvD,MAAIC,GAAG,GAAG,MAAMJ,IAAN,GAAa,qBAAb,GAAqCC,QAA/C;AACA,QAAMP,KAAK,CAAC,kBAAD,EAAqBU,GAArB,EAA0B;AAACF,IAAAA,QAAQ,EAAEA,QAAX;AAAqBC,IAAAA,IAAI,EAAEA;AAA3B,GAA1B,CAAX;AACD;;AAED,SAASL,aAAT,CAAuBO,KAAvB,EAA8BC,OAA9B,EAAuC;AACrCA,EAAAA,OAAO,GAAGA,OAAO,IAAI,EAArB,CADqC,CAGrC;;AACA,MAAIC,eAAe,GAAGD,OAAO,CAACC,eAAR,KAA4B,KAAlD;AACA,MAAIC,aAAa,GAAGF,OAAO,CAACE,aAAR,KAA0B,IAA9C;AACA,MAAIN,QAAQ,GAAGI,OAAO,CAACJ,QAAvB;AAEA,MAAIO,GAAG,GAAG,EAAV,CARqC,CASrC;AACA;;AACA,MAAIC,SAAS,GAAG,KAAhB,CAXqC,CAYrC;AACA;;AACA,MAAIC,cAAc,GAAG,KAArB;AAEA,SAAON,KAAK,CAACO,MAAN,CAAa,UAASC,GAAT,EAAc;AAChC,YAAQA,GAAG,CAACb,IAAZ;AACE,WAAK,SAAL;AACE,YAAIU,SAAJ,EAAe;AACbX,UAAAA,eAAe,CACb,SADa,EAEb,sBAFa,EAGbG,QAHa,EAIbW,GAAG,CAACV,IAJS,CAAf;AAMD,SAPD,MAOO;AACLO,UAAAA,SAAS,GAAGG,GAAG,CAACC,MAAJ,GAAaN,aAAb,GAA6BD,eAAzC;AACA,iBAAO,CAACG,SAAR;AACD;;AACH,WAAK,qBAAL;AACE,YAAI,CAACA,SAAL,EAAgB,OAAO,IAAP;;AAChB,YAAIC,cAAJ,EAAoB;AAClBZ,UAAAA,eAAe,CACb,qBADa,EAEb,+BAFa,EAGbG,QAHa,EAIbW,GAAG,CAACV,IAJS,CAAf;AAMD;;AACDQ,QAAAA,cAAc,GAAG,IAAjB;AACA,eAAO,KAAP;;AACF,WAAK,mBAAL;AACE,YAAI,CAACD,SAAL,EAAgB,OAAO,IAAP;;AAChB,YAAI,CAACC,cAAL,EAAqB;AACnBZ,UAAAA,eAAe,CACb,mBADa,EAEb,2BAFa,EAGbG,QAHa,EAIbW,GAAG,CAACV,IAJS,CAAf;AAMD;;AACDQ,QAAAA,cAAc,GAAG,KAAjB;AACAD,QAAAA,SAAS,GAAG,KAAZ;AACA,eAAO,KAAP;AACF;AACA;;AACA,WAAK,MAAL;AACE,eAAO,CAACA,SAAR;;AACF;AACE,YAAIC,cAAJ,EAAoB,OAAO,KAAP;AACpBD,QAAAA,SAAS,GAAG,KAAZ;AACA,eAAO,IAAP;AA7CJ;AA+CD,GAhDM,CAAP;AAiDD","sourcesContent":["'use strict';\n\nvar error = require('pug-error');\n\nmodule.exports = stripComments;\n\nfunction unexpectedToken(type, occasion, filename, line) {\n  var msg = '`' + type + '` encountered when ' + occasion;\n  throw error('UNEXPECTED_TOKEN', msg, {filename: filename, line: line});\n}\n\nfunction stripComments(input, options) {\n  options = options || {};\n\n  // Default: strip unbuffered comments and leave buffered ones alone\n  var stripUnbuffered = options.stripUnbuffered !== false;\n  var stripBuffered = options.stripBuffered === true;\n  var filename = options.filename;\n\n  var out = [];\n  // If we have encountered a comment token and are not sure if we have gotten\n  // out of the comment or not\n  var inComment = false;\n  // If we are sure that we are in a block comment and all tokens except\n  // `end-pipeless-text` should be ignored\n  var inPipelessText = false;\n\n  return input.filter(function(tok) {\n    switch (tok.type) {\n      case 'comment':\n        if (inComment) {\n          unexpectedToken(\n            'comment',\n            'already in a comment',\n            filename,\n            tok.line\n          );\n        } else {\n          inComment = tok.buffer ? stripBuffered : stripUnbuffered;\n          return !inComment;\n        }\n      case 'start-pipeless-text':\n        if (!inComment) return true;\n        if (inPipelessText) {\n          unexpectedToken(\n            'start-pipeless-text',\n            'already in pipeless text mode',\n            filename,\n            tok.line\n          );\n        }\n        inPipelessText = true;\n        return false;\n      case 'end-pipeless-text':\n        if (!inComment) return true;\n        if (!inPipelessText) {\n          unexpectedToken(\n            'end-pipeless-text',\n            'not in pipeless text mode',\n            filename,\n            tok.line\n          );\n        }\n        inPipelessText = false;\n        inComment = false;\n        return false;\n      // There might be a `text` right after `comment` but before\n      // `start-pipeless-text`. Treat it accordingly.\n      case 'text':\n        return !inComment;\n      default:\n        if (inPipelessText) return false;\n        inComment = false;\n        return true;\n    }\n  });\n}\n"]},"metadata":{},"sourceType":"script"}