{"ast":null,"code":"'use strict';\n\nvar objIsRegex = require('is-regex');\n\nexports = module.exports = parse;\nvar TOKEN_TYPES = exports.TOKEN_TYPES = {\n  LINE_COMMENT: '//',\n  BLOCK_COMMENT: '/**/',\n  SINGLE_QUOTE: '\\'',\n  DOUBLE_QUOTE: '\"',\n  TEMPLATE_QUOTE: '`',\n  REGEXP: '//g'\n};\nvar BRACKETS = exports.BRACKETS = {\n  '(': ')',\n  '{': '}',\n  '[': ']'\n};\nvar BRACKETS_REVERSED = {\n  ')': '(',\n  '}': '{',\n  ']': '['\n};\nexports.parse = parse;\n\nfunction parse(src, state, options) {\n  options = options || {};\n  state = state || exports.defaultState();\n  var start = options.start || 0;\n  var end = options.end || src.length;\n  var index = start;\n\n  while (index < end) {\n    try {\n      parseChar(src[index], state);\n    } catch (ex) {\n      ex.index = index;\n      throw ex;\n    }\n\n    index++;\n  }\n\n  return state;\n}\n\nexports.parseUntil = parseUntil;\n\nfunction parseUntil(src, delimiter, options) {\n  options = options || {};\n  var start = options.start || 0;\n  var index = start;\n  var state = exports.defaultState();\n\n  while (index < src.length) {\n    if ((options.ignoreNesting || !state.isNesting(options)) && matches(src, delimiter, index)) {\n      var end = index;\n      return {\n        start: start,\n        end: end,\n        src: src.substring(start, end)\n      };\n    }\n\n    try {\n      parseChar(src[index], state);\n    } catch (ex) {\n      ex.index = index;\n      throw ex;\n    }\n\n    index++;\n  }\n\n  var err = new Error('The end of the string was reached with no closing bracket found.');\n  err.code = 'CHARACTER_PARSER:END_OF_STRING_REACHED';\n  err.index = index;\n  throw err;\n}\n\nexports.parseChar = parseChar;\n\nfunction parseChar(character, state) {\n  if (character.length !== 1) {\n    var err = new Error('Character must be a string of length 1');\n    err.name = 'InvalidArgumentError';\n    err.code = 'CHARACTER_PARSER:CHAR_LENGTH_NOT_ONE';\n    throw err;\n  }\n\n  state = state || exports.defaultState();\n  state.src += character;\n  var wasComment = state.isComment();\n  var lastChar = state.history ? state.history[0] : '';\n\n  if (state.regexpStart) {\n    if (character === '/' || character == '*') {\n      state.stack.pop();\n    }\n\n    state.regexpStart = false;\n  }\n\n  switch (state.current()) {\n    case TOKEN_TYPES.LINE_COMMENT:\n      if (character === '\\n') {\n        state.stack.pop();\n      }\n\n      break;\n\n    case TOKEN_TYPES.BLOCK_COMMENT:\n      if (state.lastChar === '*' && character === '/') {\n        state.stack.pop();\n      }\n\n      break;\n\n    case TOKEN_TYPES.SINGLE_QUOTE:\n      if (character === '\\'' && !state.escaped) {\n        state.stack.pop();\n      } else if (character === '\\\\' && !state.escaped) {\n        state.escaped = true;\n      } else {\n        state.escaped = false;\n      }\n\n      break;\n\n    case TOKEN_TYPES.DOUBLE_QUOTE:\n      if (character === '\"' && !state.escaped) {\n        state.stack.pop();\n      } else if (character === '\\\\' && !state.escaped) {\n        state.escaped = true;\n      } else {\n        state.escaped = false;\n      }\n\n      break;\n\n    case TOKEN_TYPES.TEMPLATE_QUOTE:\n      if (character === '`' && !state.escaped) {\n        state.stack.pop();\n        state.hasDollar = false;\n      } else if (character === '\\\\' && !state.escaped) {\n        state.escaped = true;\n        state.hasDollar = false;\n      } else if (character === '$' && !state.escaped) {\n        state.hasDollar = true;\n      } else if (character === '{' && state.hasDollar) {\n        state.stack.push(BRACKETS[character]);\n      } else {\n        state.escaped = false;\n        state.hasDollar = false;\n      }\n\n      break;\n\n    case TOKEN_TYPES.REGEXP:\n      if (character === '/' && !state.escaped) {\n        state.stack.pop();\n      } else if (character === '\\\\' && !state.escaped) {\n        state.escaped = true;\n      } else {\n        state.escaped = false;\n      }\n\n      break;\n\n    default:\n      if (character in BRACKETS) {\n        state.stack.push(BRACKETS[character]);\n      } else if (character in BRACKETS_REVERSED) {\n        if (state.current() !== character) {\n          var err = new SyntaxError('Mismatched Bracket: ' + character);\n          err.code = 'CHARACTER_PARSER:MISMATCHED_BRACKET';\n          throw err;\n        }\n\n        ;\n        state.stack.pop();\n      } else if (lastChar === '/' && character === '/') {\n        // Don't include comments in history\n        state.history = state.history.substr(1);\n        state.stack.push(TOKEN_TYPES.LINE_COMMENT);\n      } else if (lastChar === '/' && character === '*') {\n        // Don't include comment in history\n        state.history = state.history.substr(1);\n        state.stack.push(TOKEN_TYPES.BLOCK_COMMENT);\n      } else if (character === '/' && isRegexp(state.history)) {\n        state.stack.push(TOKEN_TYPES.REGEXP); // N.B. if the next character turns out to be a `*` or a `/`\n        //      then this isn't actually a regexp\n\n        state.regexpStart = true;\n      } else if (character === '\\'') {\n        state.stack.push(TOKEN_TYPES.SINGLE_QUOTE);\n      } else if (character === '\"') {\n        state.stack.push(TOKEN_TYPES.DOUBLE_QUOTE);\n      } else if (character === '`') {\n        state.stack.push(TOKEN_TYPES.TEMPLATE_QUOTE);\n      }\n\n      break;\n  }\n\n  if (!state.isComment() && !wasComment) {\n    state.history = character + state.history;\n  }\n\n  state.lastChar = character; // store last character for ending block comments\n\n  return state;\n}\n\nexports.defaultState = function () {\n  return new State();\n};\n\nfunction State() {\n  this.stack = [];\n  this.regexpStart = false;\n  this.escaped = false;\n  this.hasDollar = false;\n  this.src = '';\n  this.history = '';\n  this.lastChar = '';\n}\n\nState.prototype.current = function () {\n  return this.stack[this.stack.length - 1];\n};\n\nState.prototype.isString = function () {\n  return this.current() === TOKEN_TYPES.SINGLE_QUOTE || this.current() === TOKEN_TYPES.DOUBLE_QUOTE || this.current() === TOKEN_TYPES.TEMPLATE_QUOTE;\n};\n\nState.prototype.isComment = function () {\n  return this.current() === TOKEN_TYPES.LINE_COMMENT || this.current() === TOKEN_TYPES.BLOCK_COMMENT;\n};\n\nState.prototype.isNesting = function (opts) {\n  if (opts && opts.ignoreLineComment && this.stack.length === 1 && this.stack[0] === TOKEN_TYPES.LINE_COMMENT) {\n    // if we are only inside a line comment, and line comments are ignored\n    // don't count it as nesting\n    return false;\n  }\n\n  return !!this.stack.length;\n};\n\nfunction matches(str, matcher, i) {\n  if (objIsRegex(matcher)) {\n    return matcher.test(str.substr(i || 0));\n  } else {\n    return str.substr(i || 0, matcher.length) === matcher;\n  }\n}\n\nexports.isPunctuator = isPunctuator;\n\nfunction isPunctuator(c) {\n  if (!c) return true; // the start of a string is a punctuator\n\n  var code = c.charCodeAt(0);\n\n  switch (code) {\n    case 46: // . dot\n\n    case 40: // ( open bracket\n\n    case 41: // ) close bracket\n\n    case 59: // ; semicolon\n\n    case 44: // , comma\n\n    case 123: // { open curly brace\n\n    case 125: // } close curly brace\n\n    case 91: // [\n\n    case 93: // ]\n\n    case 58: // :\n\n    case 63: // ?\n\n    case 126: // ~\n\n    case 37: // %\n\n    case 38: // &\n\n    case 42: // *:\n\n    case 43: // +\n\n    case 45: // -\n\n    case 47: // /\n\n    case 60: // <\n\n    case 62: // >\n\n    case 94: // ^\n\n    case 124: // |\n\n    case 33: // !\n\n    case 61:\n      // =\n      return true;\n\n    default:\n      return false;\n  }\n}\n\nexports.isKeyword = isKeyword;\n\nfunction isKeyword(id) {\n  return id === 'if' || id === 'in' || id === 'do' || id === 'var' || id === 'for' || id === 'new' || id === 'try' || id === 'let' || id === 'this' || id === 'else' || id === 'case' || id === 'void' || id === 'with' || id === 'enum' || id === 'while' || id === 'break' || id === 'catch' || id === 'throw' || id === 'const' || id === 'yield' || id === 'class' || id === 'super' || id === 'return' || id === 'typeof' || id === 'delete' || id === 'switch' || id === 'export' || id === 'import' || id === 'default' || id === 'finally' || id === 'extends' || id === 'function' || id === 'continue' || id === 'debugger' || id === 'package' || id === 'private' || id === 'interface' || id === 'instanceof' || id === 'implements' || id === 'protected' || id === 'public' || id === 'static';\n}\n\nfunction isRegexp(history) {\n  //could be start of regexp or divide sign\n  history = history.replace(/^\\s*/, ''); //unless its an `if`, `while`, `for` or `with` it's a divide, so we assume it's a divide\n\n  if (history[0] === ')') return false; //unless it's a function expression, it's a regexp, so we assume it's a regexp\n\n  if (history[0] === '}') return true; //any punctuation means it's a regexp\n\n  if (isPunctuator(history[0])) return true; //if the last thing was a keyword then it must be a regexp (e.g. `typeof /foo/`)\n\n  if (/^\\w+\\b/.test(history) && isKeyword(/^\\w+\\b/.exec(history)[0].split('').reverse().join(''))) return true;\n  return false;\n}","map":{"version":3,"sources":["C:/Users/bekke/Documents/Art Website/node_modules/character-parser/index.js"],"names":["objIsRegex","require","exports","module","parse","TOKEN_TYPES","LINE_COMMENT","BLOCK_COMMENT","SINGLE_QUOTE","DOUBLE_QUOTE","TEMPLATE_QUOTE","REGEXP","BRACKETS","BRACKETS_REVERSED","src","state","options","defaultState","start","end","length","index","parseChar","ex","parseUntil","delimiter","ignoreNesting","isNesting","matches","substring","err","Error","code","character","name","wasComment","isComment","lastChar","history","regexpStart","stack","pop","current","escaped","hasDollar","push","SyntaxError","substr","isRegexp","State","prototype","isString","opts","ignoreLineComment","str","matcher","i","test","isPunctuator","c","charCodeAt","isKeyword","id","replace","exec","split","reverse","join"],"mappings":"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","sourcesContent":["'use strict';\n\nvar objIsRegex = require('is-regex');\n\nexports = (module.exports = parse);\n\nvar TOKEN_TYPES = exports.TOKEN_TYPES = {\n  LINE_COMMENT: '//',\n  BLOCK_COMMENT: '/**/',\n  SINGLE_QUOTE: '\\'',\n  DOUBLE_QUOTE: '\"',\n  TEMPLATE_QUOTE: '`',\n  REGEXP: '//g'\n}\n\nvar BRACKETS = exports.BRACKETS = {\n  '(': ')',\n  '{': '}',\n  '[': ']'\n};\nvar BRACKETS_REVERSED = {\n  ')': '(',\n  '}': '{',\n  ']': '['\n};\n\nexports.parse = parse;\nfunction parse(src, state, options) {\n  options = options || {};\n  state = state || exports.defaultState();\n  var start = options.start || 0;\n  var end = options.end || src.length;\n  var index = start;\n  while (index < end) {\n    try {\n      parseChar(src[index], state);\n    } catch (ex) {\n      ex.index = index;\n      throw ex;\n    }\n    index++;\n  }\n  return state;\n}\n\nexports.parseUntil = parseUntil;\nfunction parseUntil(src, delimiter, options) {\n  options = options || {};\n  var start = options.start || 0;\n  var index = start;\n  var state = exports.defaultState();\n  while (index < src.length) {\n    if ((options.ignoreNesting || !state.isNesting(options)) && matches(src, delimiter, index)) {\n      var end = index;\n      return {\n        start: start,\n        end: end,\n        src: src.substring(start, end)\n      };\n    }\n    try {\n      parseChar(src[index], state);\n    } catch (ex) {\n      ex.index = index;\n      throw ex;\n    }\n    index++;\n  }\n  var err = new Error('The end of the string was reached with no closing bracket found.');\n  err.code = 'CHARACTER_PARSER:END_OF_STRING_REACHED';\n  err.index = index;\n  throw err;\n}\n\nexports.parseChar = parseChar;\nfunction parseChar(character, state) {\n  if (character.length !== 1) {\n    var err = new Error('Character must be a string of length 1');\n    err.name = 'InvalidArgumentError';\n    err.code = 'CHARACTER_PARSER:CHAR_LENGTH_NOT_ONE';\n    throw err;\n  }\n  state = state || exports.defaultState();\n  state.src += character;\n  var wasComment = state.isComment();\n  var lastChar = state.history ? state.history[0] : '';\n\n\n  if (state.regexpStart) {\n    if (character === '/' || character == '*') {\n      state.stack.pop();\n    }\n    state.regexpStart = false;\n  }\n  switch (state.current()) {\n    case TOKEN_TYPES.LINE_COMMENT:\n      if (character === '\\n') {\n        state.stack.pop();\n      }\n      break;\n    case TOKEN_TYPES.BLOCK_COMMENT:\n      if (state.lastChar === '*' && character === '/') {\n        state.stack.pop();\n      }\n      break;\n    case TOKEN_TYPES.SINGLE_QUOTE:\n      if (character === '\\'' && !state.escaped) {\n        state.stack.pop();\n      } else if (character === '\\\\' && !state.escaped) {\n        state.escaped = true;\n      } else {\n        state.escaped = false;\n      }\n      break;\n    case TOKEN_TYPES.DOUBLE_QUOTE:\n      if (character === '\"' && !state.escaped) {\n        state.stack.pop();\n      } else if (character === '\\\\' && !state.escaped) {\n        state.escaped = true;\n      } else {\n        state.escaped = false;\n      }\n      break;\n    case TOKEN_TYPES.TEMPLATE_QUOTE:\n      if (character === '`' && !state.escaped) {\n        state.stack.pop();\n        state.hasDollar = false;\n      } else if (character === '\\\\' && !state.escaped) {\n        state.escaped = true;\n        state.hasDollar = false;\n      } else if (character === '$' && !state.escaped) {\n        state.hasDollar = true;\n      } else if (character === '{' && state.hasDollar) {\n        state.stack.push(BRACKETS[character]);\n      } else {\n        state.escaped = false;\n        state.hasDollar = false;\n      }\n      break;\n    case TOKEN_TYPES.REGEXP:\n      if (character === '/' && !state.escaped) {\n        state.stack.pop();\n      } else if (character === '\\\\' && !state.escaped) {\n        state.escaped = true;\n      } else {\n        state.escaped = false;\n      }\n      break;\n    default:\n      if (character in BRACKETS) {\n        state.stack.push(BRACKETS[character]);\n      } else if (character in BRACKETS_REVERSED) {\n        if (state.current() !== character) {\n          var err = new SyntaxError('Mismatched Bracket: ' + character);\n          err.code = 'CHARACTER_PARSER:MISMATCHED_BRACKET';\n          throw err;\n        };\n        state.stack.pop();\n      } else if (lastChar === '/' && character === '/') {\n        // Don't include comments in history\n        state.history = state.history.substr(1);\n        state.stack.push(TOKEN_TYPES.LINE_COMMENT);\n      } else if (lastChar === '/' && character === '*') {\n        // Don't include comment in history\n        state.history = state.history.substr(1);\n        state.stack.push(TOKEN_TYPES.BLOCK_COMMENT);\n      } else if (character === '/' && isRegexp(state.history)) {\n        state.stack.push(TOKEN_TYPES.REGEXP);\n        // N.B. if the next character turns out to be a `*` or a `/`\n        //      then this isn't actually a regexp\n        state.regexpStart = true;\n      } else if (character === '\\'') {\n        state.stack.push(TOKEN_TYPES.SINGLE_QUOTE);\n      } else if (character === '\"') {\n        state.stack.push(TOKEN_TYPES.DOUBLE_QUOTE);\n      } else if (character === '`') {\n        state.stack.push(TOKEN_TYPES.TEMPLATE_QUOTE);\n      }\n      break;\n  }\n  if (!state.isComment() && !wasComment) {\n    state.history = character + state.history;\n  }\n  state.lastChar = character; // store last character for ending block comments\n  return state;\n}\n\nexports.defaultState = function () { return new State() };\nfunction State() {\n  this.stack = [];\n\n  this.regexpStart = false;\n  this.escaped = false;\n  this.hasDollar = false;\n\n  this.src = '';\n  this.history = ''\n  this.lastChar = ''\n}\nState.prototype.current = function () {\n  return this.stack[this.stack.length - 1];\n};\nState.prototype.isString = function () {\n  return (\n    this.current() === TOKEN_TYPES.SINGLE_QUOTE ||\n    this.current() === TOKEN_TYPES.DOUBLE_QUOTE ||\n    this.current() === TOKEN_TYPES.TEMPLATE_QUOTE\n  );\n}\nState.prototype.isComment = function () {\n  return this.current() === TOKEN_TYPES.LINE_COMMENT || this.current() === TOKEN_TYPES.BLOCK_COMMENT;\n}\nState.prototype.isNesting = function (opts) {\n  if (\n    opts && opts.ignoreLineComment &&\n    this.stack.length === 1 && this.stack[0] === TOKEN_TYPES.LINE_COMMENT\n  ) {\n    // if we are only inside a line comment, and line comments are ignored\n    // don't count it as nesting\n    return false;\n  }\n  return !!this.stack.length;\n}\n\nfunction matches(str, matcher, i) {\n  if (objIsRegex(matcher)) {\n    return matcher.test(str.substr(i || 0));\n  } else {\n    return str.substr(i || 0, matcher.length) === matcher;\n  }\n}\n\nexports.isPunctuator = isPunctuator\nfunction isPunctuator(c) {\n  if (!c) return true; // the start of a string is a punctuator\n  var code = c.charCodeAt(0)\n\n  switch (code) {\n    case 46:   // . dot\n    case 40:   // ( open bracket\n    case 41:   // ) close bracket\n    case 59:   // ; semicolon\n    case 44:   // , comma\n    case 123:  // { open curly brace\n    case 125:  // } close curly brace\n    case 91:   // [\n    case 93:   // ]\n    case 58:   // :\n    case 63:   // ?\n    case 126:  // ~\n    case 37:   // %\n    case 38:   // &\n    case 42:   // *:\n    case 43:   // +\n    case 45:   // -\n    case 47:   // /\n    case 60:   // <\n    case 62:   // >\n    case 94:   // ^\n    case 124:  // |\n    case 33:   // !\n    case 61:   // =\n      return true;\n    default:\n      return false;\n  }\n}\n\nexports.isKeyword = isKeyword\nfunction isKeyword(id) {\n  return (id === 'if') || (id === 'in') || (id === 'do') || (id === 'var') || (id === 'for') || (id === 'new') ||\n         (id === 'try') || (id === 'let') || (id === 'this') || (id === 'else') || (id === 'case') ||\n         (id === 'void') || (id === 'with') || (id === 'enum') || (id === 'while') || (id === 'break') || (id === 'catch') ||\n         (id === 'throw') || (id === 'const') || (id === 'yield') || (id === 'class') || (id === 'super') ||\n         (id === 'return') || (id === 'typeof') || (id === 'delete') || (id === 'switch') || (id === 'export') ||\n         (id === 'import') || (id === 'default') || (id === 'finally') || (id === 'extends') || (id === 'function') ||\n         (id === 'continue') || (id === 'debugger') || (id === 'package') || (id === 'private') || (id === 'interface') ||\n         (id === 'instanceof') || (id === 'implements') || (id === 'protected') || (id === 'public') || (id === 'static');\n}\n\nfunction isRegexp(history) {\n  //could be start of regexp or divide sign\n\n  history = history.replace(/^\\s*/, '');\n\n  //unless its an `if`, `while`, `for` or `with` it's a divide, so we assume it's a divide\n  if (history[0] === ')') return false;\n  //unless it's a function expression, it's a regexp, so we assume it's a regexp\n  if (history[0] === '}') return true;\n  //any punctuation means it's a regexp\n  if (isPunctuator(history[0])) return true;\n  //if the last thing was a keyword then it must be a regexp (e.g. `typeof /foo/`)\n  if (/^\\w+\\b/.test(history) && isKeyword(/^\\w+\\b/.exec(history)[0].split('').reverse().join(''))) return true;\n\n  return false;\n}\n"]},"metadata":{},"sourceType":"script"}