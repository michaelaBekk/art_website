{"ast":null,"code":"'use strict';\n\nvar assert = require('assert');\n\nvar TokenStream = require('token-stream');\n\nvar error = require('pug-error');\n\nvar inlineTags = require('./lib/inline-tags');\n\nmodule.exports = parse;\nmodule.exports.Parser = Parser;\n\nfunction parse(tokens, options) {\n  var parser = new Parser(tokens, options);\n  var ast = parser.parse();\n  return JSON.parse(JSON.stringify(ast));\n}\n/**\n * Initialize `Parser` with the given input `str` and `filename`.\n *\n * @param {String} str\n * @param {String} filename\n * @param {Object} options\n * @api public\n */\n\n\nfunction Parser(tokens, options) {\n  options = options || {};\n\n  if (!Array.isArray(tokens)) {\n    throw new Error('Expected tokens to be an Array but got \"' + typeof tokens + '\"');\n  }\n\n  if (typeof options !== 'object') {\n    throw new Error('Expected \"options\" to be an object but got \"' + typeof options + '\"');\n  }\n\n  this.tokens = new TokenStream(tokens);\n  this.filename = options.filename;\n  this.src = options.src;\n  this.inMixin = 0;\n  this.plugins = options.plugins || [];\n}\n/**\n * Parser prototype.\n */\n\n\nParser.prototype = {\n  /**\n   * Save original constructor\n   */\n  constructor: Parser,\n  error: function (code, message, token) {\n    var err = error(code, message, {\n      line: token.loc.start.line,\n      column: token.loc.start.column,\n      filename: this.filename,\n      src: this.src\n    });\n    throw err;\n  },\n\n  /**\n   * Return the next token object.\n   *\n   * @return {Object}\n   * @api private\n   */\n  advance: function () {\n    return this.tokens.advance();\n  },\n\n  /**\n   * Single token lookahead.\n   *\n   * @return {Object}\n   * @api private\n   */\n  peek: function () {\n    return this.tokens.peek();\n  },\n\n  /**\n   * `n` token lookahead.\n   *\n   * @param {Number} n\n   * @return {Object}\n   * @api private\n   */\n  lookahead: function (n) {\n    return this.tokens.lookahead(n);\n  },\n\n  /**\n   * Parse input returning a string of js for evaluation.\n   *\n   * @return {String}\n   * @api public\n   */\n  parse: function () {\n    var block = this.emptyBlock(0);\n\n    while ('eos' != this.peek().type) {\n      if ('newline' == this.peek().type) {\n        this.advance();\n      } else if ('text-html' == this.peek().type) {\n        block.nodes = block.nodes.concat(this.parseTextHtml());\n      } else {\n        var expr = this.parseExpr();\n\n        if (expr) {\n          if (expr.type === 'Block') {\n            block.nodes = block.nodes.concat(expr.nodes);\n          } else {\n            block.nodes.push(expr);\n          }\n        }\n      }\n    }\n\n    return block;\n  },\n\n  /**\n   * Expect the given type, or throw an exception.\n   *\n   * @param {String} type\n   * @api private\n   */\n  expect: function (type) {\n    if (this.peek().type === type) {\n      return this.advance();\n    } else {\n      this.error('INVALID_TOKEN', 'expected \"' + type + '\", but got \"' + this.peek().type + '\"', this.peek());\n    }\n  },\n\n  /**\n   * Accept the given `type`.\n   *\n   * @param {String} type\n   * @api private\n   */\n  accept: function (type) {\n    if (this.peek().type === type) {\n      return this.advance();\n    }\n  },\n  initBlock: function (line, nodes) {\n    /* istanbul ignore if */\n    if ((line | 0) !== line) throw new Error('`line` is not an integer');\n    /* istanbul ignore if */\n\n    if (!Array.isArray(nodes)) throw new Error('`nodes` is not an array');\n    return {\n      type: 'Block',\n      nodes: nodes,\n      line: line,\n      filename: this.filename\n    };\n  },\n  emptyBlock: function (line) {\n    return this.initBlock(line, []);\n  },\n  runPlugin: function (context, tok) {\n    var rest = [this];\n\n    for (var i = 2; i < arguments.length; i++) {\n      rest.push(arguments[i]);\n    }\n\n    var pluginContext;\n\n    for (var i = 0; i < this.plugins.length; i++) {\n      var plugin = this.plugins[i];\n\n      if (plugin[context] && plugin[context][tok.type]) {\n        if (pluginContext) throw new Error('Multiple plugin handlers found for context ' + JSON.stringify(context) + ', token type ' + JSON.stringify(tok.type));\n        pluginContext = plugin[context];\n      }\n    }\n\n    if (pluginContext) return pluginContext[tok.type].apply(pluginContext, rest);\n  },\n\n  /**\n   *   tag\n   * | doctype\n   * | mixin\n   * | include\n   * | filter\n   * | comment\n   * | text\n   * | text-html\n   * | dot\n   * | each\n   * | code\n   * | yield\n   * | id\n   * | class\n   * | interpolation\n   */\n  parseExpr: function () {\n    switch (this.peek().type) {\n      case 'tag':\n        return this.parseTag();\n\n      case 'mixin':\n        return this.parseMixin();\n\n      case 'block':\n        return this.parseBlock();\n\n      case 'mixin-block':\n        return this.parseMixinBlock();\n\n      case 'case':\n        return this.parseCase();\n\n      case 'extends':\n        return this.parseExtends();\n\n      case 'include':\n        return this.parseInclude();\n\n      case 'doctype':\n        return this.parseDoctype();\n\n      case 'filter':\n        return this.parseFilter();\n\n      case 'comment':\n        return this.parseComment();\n\n      case 'text':\n      case 'interpolated-code':\n      case 'start-pug-interpolation':\n        return this.parseText({\n          block: true\n        });\n\n      case 'text-html':\n        return this.initBlock(this.peek().loc.start.line, this.parseTextHtml());\n\n      case 'dot':\n        return this.parseDot();\n\n      case 'each':\n        return this.parseEach();\n\n      case 'eachOf':\n        return this.parseEachOf();\n\n      case 'code':\n        return this.parseCode();\n\n      case 'blockcode':\n        return this.parseBlockCode();\n\n      case 'if':\n        return this.parseConditional();\n\n      case 'while':\n        return this.parseWhile();\n\n      case 'call':\n        return this.parseCall();\n\n      case 'interpolation':\n        return this.parseInterpolation();\n\n      case 'yield':\n        return this.parseYield();\n\n      case 'id':\n      case 'class':\n        if (!this.peek().loc.start) debugger;\n        this.tokens.defer({\n          type: 'tag',\n          val: 'div',\n          loc: this.peek().loc,\n          filename: this.filename\n        });\n        return this.parseExpr();\n\n      default:\n        var pluginResult = this.runPlugin('expressionTokens', this.peek());\n        if (pluginResult) return pluginResult;\n        this.error('INVALID_TOKEN', 'unexpected token \"' + this.peek().type + '\"', this.peek());\n    }\n  },\n  parseDot: function () {\n    this.advance();\n    return this.parseTextBlock();\n  },\n\n  /**\n   * Text\n   */\n  parseText: function (options) {\n    var tags = [];\n    var lineno = this.peek().loc.start.line;\n    var nextTok = this.peek();\n\n    loop: while (true) {\n      switch (nextTok.type) {\n        case 'text':\n          var tok = this.advance();\n          tags.push({\n            type: 'Text',\n            val: tok.val,\n            line: tok.loc.start.line,\n            column: tok.loc.start.column,\n            filename: this.filename\n          });\n          break;\n\n        case 'interpolated-code':\n          var tok = this.advance();\n          tags.push({\n            type: 'Code',\n            val: tok.val,\n            buffer: tok.buffer,\n            mustEscape: tok.mustEscape !== false,\n            isInline: true,\n            line: tok.loc.start.line,\n            column: tok.loc.start.column,\n            filename: this.filename\n          });\n          break;\n\n        case 'newline':\n          if (!options || !options.block) break loop;\n          var tok = this.advance();\n          var nextType = this.peek().type;\n\n          if (nextType === 'text' || nextType === 'interpolated-code') {\n            tags.push({\n              type: 'Text',\n              val: '\\n',\n              line: tok.loc.start.line,\n              column: tok.loc.start.column,\n              filename: this.filename\n            });\n          }\n\n          break;\n\n        case 'start-pug-interpolation':\n          this.advance();\n          tags.push(this.parseExpr());\n          this.expect('end-pug-interpolation');\n          break;\n\n        default:\n          var pluginResult = this.runPlugin('textTokens', nextTok, tags);\n          if (pluginResult) break;\n          break loop;\n      }\n\n      nextTok = this.peek();\n    }\n\n    if (tags.length === 1) return tags[0];else return this.initBlock(lineno, tags);\n  },\n  parseTextHtml: function () {\n    var nodes = [];\n    var currentNode = null;\n\n    loop: while (true) {\n      switch (this.peek().type) {\n        case 'text-html':\n          var text = this.advance();\n\n          if (!currentNode) {\n            currentNode = {\n              type: 'Text',\n              val: text.val,\n              filename: this.filename,\n              line: text.loc.start.line,\n              column: text.loc.start.column,\n              isHtml: true\n            };\n            nodes.push(currentNode);\n          } else {\n            currentNode.val += '\\n' + text.val;\n          }\n\n          break;\n\n        case 'indent':\n          var block = this.block();\n          block.nodes.forEach(function (node) {\n            if (node.isHtml) {\n              if (!currentNode) {\n                currentNode = node;\n                nodes.push(currentNode);\n              } else {\n                currentNode.val += '\\n' + node.val;\n              }\n            } else {\n              currentNode = null;\n              nodes.push(node);\n            }\n          });\n          break;\n\n        case 'code':\n          currentNode = null;\n          nodes.push(this.parseCode(true));\n          break;\n\n        case 'newline':\n          this.advance();\n          break;\n\n        default:\n          break loop;\n      }\n    }\n\n    return nodes;\n  },\n\n  /**\n   *   ':' expr\n   * | block\n   */\n  parseBlockExpansion: function () {\n    var tok = this.accept(':');\n\n    if (tok) {\n      var expr = this.parseExpr();\n      return expr.type === 'Block' ? expr : this.initBlock(tok.loc.start.line, [expr]);\n    } else {\n      return this.block();\n    }\n  },\n\n  /**\n   * case\n   */\n  parseCase: function () {\n    var tok = this.expect('case');\n    var node = {\n      type: 'Case',\n      expr: tok.val,\n      line: tok.loc.start.line,\n      column: tok.loc.start.column,\n      filename: this.filename\n    };\n    var block = this.emptyBlock(tok.loc.start.line + 1);\n    this.expect('indent');\n\n    while ('outdent' != this.peek().type) {\n      switch (this.peek().type) {\n        case 'comment':\n        case 'newline':\n          this.advance();\n          break;\n\n        case 'when':\n          block.nodes.push(this.parseWhen());\n          break;\n\n        case 'default':\n          block.nodes.push(this.parseDefault());\n          break;\n\n        default:\n          var pluginResult = this.runPlugin('caseTokens', this.peek(), block);\n          if (pluginResult) break;\n          this.error('INVALID_TOKEN', 'Unexpected token \"' + this.peek().type + '\", expected \"when\", \"default\" or \"newline\"', this.peek());\n      }\n    }\n\n    this.expect('outdent');\n    node.block = block;\n    return node;\n  },\n\n  /**\n   * when\n   */\n  parseWhen: function () {\n    var tok = this.expect('when');\n\n    if (this.peek().type !== 'newline') {\n      return {\n        type: 'When',\n        expr: tok.val,\n        block: this.parseBlockExpansion(),\n        debug: false,\n        line: tok.loc.start.line,\n        column: tok.loc.start.column,\n        filename: this.filename\n      };\n    } else {\n      return {\n        type: 'When',\n        expr: tok.val,\n        debug: false,\n        line: tok.loc.start.line,\n        column: tok.loc.start.column,\n        filename: this.filename\n      };\n    }\n  },\n\n  /**\n   * default\n   */\n  parseDefault: function () {\n    var tok = this.expect('default');\n    return {\n      type: 'When',\n      expr: 'default',\n      block: this.parseBlockExpansion(),\n      debug: false,\n      line: tok.loc.start.line,\n      column: tok.loc.start.column,\n      filename: this.filename\n    };\n  },\n\n  /**\n   * code\n   */\n  parseCode: function (noBlock) {\n    var tok = this.expect('code');\n    assert(typeof tok.mustEscape === 'boolean', 'Please update to the newest version of pug-lexer.');\n    var node = {\n      type: 'Code',\n      val: tok.val,\n      buffer: tok.buffer,\n      mustEscape: tok.mustEscape !== false,\n      isInline: !!noBlock,\n      line: tok.loc.start.line,\n      column: tok.loc.start.column,\n      filename: this.filename\n    }; // todo: why is this here?  It seems like a hacky workaround\n\n    if (node.val.match(/^ *else/)) node.debug = false;\n    if (noBlock) return node;\n    var block; // handle block\n\n    block = 'indent' == this.peek().type;\n\n    if (block) {\n      if (tok.buffer) {\n        this.error('BLOCK_IN_BUFFERED_CODE', 'Buffered code cannot have a block attached to it', this.peek());\n      }\n\n      node.block = this.block();\n    }\n\n    return node;\n  },\n  parseConditional: function () {\n    var tok = this.expect('if');\n    var node = {\n      type: 'Conditional',\n      test: tok.val,\n      consequent: this.emptyBlock(tok.loc.start.line),\n      alternate: null,\n      line: tok.loc.start.line,\n      column: tok.loc.start.column,\n      filename: this.filename\n    }; // handle block\n\n    if ('indent' == this.peek().type) {\n      node.consequent = this.block();\n    }\n\n    var currentNode = node;\n\n    while (true) {\n      if (this.peek().type === 'newline') {\n        this.expect('newline');\n      } else if (this.peek().type === 'else-if') {\n        tok = this.expect('else-if');\n        currentNode = currentNode.alternate = {\n          type: 'Conditional',\n          test: tok.val,\n          consequent: this.emptyBlock(tok.loc.start.line),\n          alternate: null,\n          line: tok.loc.start.line,\n          column: tok.loc.start.column,\n          filename: this.filename\n        };\n\n        if ('indent' == this.peek().type) {\n          currentNode.consequent = this.block();\n        }\n      } else if (this.peek().type === 'else') {\n        this.expect('else');\n\n        if (this.peek().type === 'indent') {\n          currentNode.alternate = this.block();\n        }\n\n        break;\n      } else {\n        break;\n      }\n    }\n\n    return node;\n  },\n  parseWhile: function () {\n    var tok = this.expect('while');\n    var node = {\n      type: 'While',\n      test: tok.val,\n      line: tok.loc.start.line,\n      column: tok.loc.start.column,\n      filename: this.filename\n    }; // handle block\n\n    if ('indent' == this.peek().type) {\n      node.block = this.block();\n    } else {\n      node.block = this.emptyBlock(tok.loc.start.line);\n    }\n\n    return node;\n  },\n\n  /**\n   * block code\n   */\n  parseBlockCode: function () {\n    var tok = this.expect('blockcode');\n    var line = tok.loc.start.line;\n    var column = tok.loc.start.column;\n    var body = this.peek();\n    var text = '';\n\n    if (body.type === 'start-pipeless-text') {\n      this.advance();\n\n      while (this.peek().type !== 'end-pipeless-text') {\n        tok = this.advance();\n\n        switch (tok.type) {\n          case 'text':\n            text += tok.val;\n            break;\n\n          case 'newline':\n            text += '\\n';\n            break;\n\n          default:\n            var pluginResult = this.runPlugin('blockCodeTokens', tok, tok);\n\n            if (pluginResult) {\n              text += pluginResult;\n              break;\n            }\n\n            this.error('INVALID_TOKEN', 'Unexpected token type: ' + tok.type, tok);\n        }\n      }\n\n      this.advance();\n    }\n\n    return {\n      type: 'Code',\n      val: text,\n      buffer: false,\n      mustEscape: false,\n      isInline: false,\n      line: line,\n      column: column,\n      filename: this.filename\n    };\n  },\n\n  /**\n   * comment\n   */\n  parseComment: function () {\n    var tok = this.expect('comment');\n    var block;\n\n    if (block = this.parseTextBlock()) {\n      return {\n        type: 'BlockComment',\n        val: tok.val,\n        block: block,\n        buffer: tok.buffer,\n        line: tok.loc.start.line,\n        column: tok.loc.start.column,\n        filename: this.filename\n      };\n    } else {\n      return {\n        type: 'Comment',\n        val: tok.val,\n        buffer: tok.buffer,\n        line: tok.loc.start.line,\n        column: tok.loc.start.column,\n        filename: this.filename\n      };\n    }\n  },\n\n  /**\n   * doctype\n   */\n  parseDoctype: function () {\n    var tok = this.expect('doctype');\n    return {\n      type: 'Doctype',\n      val: tok.val,\n      line: tok.loc.start.line,\n      column: tok.loc.start.column,\n      filename: this.filename\n    };\n  },\n  parseIncludeFilter: function () {\n    var tok = this.expect('filter');\n    var attrs = [];\n\n    if (this.peek().type === 'start-attributes') {\n      attrs = this.attrs();\n    }\n\n    return {\n      type: 'IncludeFilter',\n      name: tok.val,\n      attrs: attrs,\n      line: tok.loc.start.line,\n      column: tok.loc.start.column,\n      filename: this.filename\n    };\n  },\n\n  /**\n   * filter attrs? text-block\n   */\n  parseFilter: function () {\n    var tok = this.expect('filter');\n    var block,\n        attrs = [];\n\n    if (this.peek().type === 'start-attributes') {\n      attrs = this.attrs();\n    }\n\n    if (this.peek().type === 'text') {\n      var textToken = this.advance();\n      block = this.initBlock(textToken.loc.start.line, [{\n        type: 'Text',\n        val: textToken.val,\n        line: textToken.loc.start.line,\n        column: textToken.loc.start.column,\n        filename: this.filename\n      }]);\n    } else if (this.peek().type === 'filter') {\n      block = this.initBlock(tok.loc.start.line, [this.parseFilter()]);\n    } else {\n      block = this.parseTextBlock() || this.emptyBlock(tok.loc.start.line);\n    }\n\n    return {\n      type: 'Filter',\n      name: tok.val,\n      block: block,\n      attrs: attrs,\n      line: tok.loc.start.line,\n      column: tok.loc.start.column,\n      filename: this.filename\n    };\n  },\n\n  /**\n   * each block\n   */\n  parseEach: function () {\n    var tok = this.expect('each');\n    var node = {\n      type: 'Each',\n      obj: tok.code,\n      val: tok.val,\n      key: tok.key,\n      block: this.block(),\n      line: tok.loc.start.line,\n      column: tok.loc.start.column,\n      filename: this.filename\n    };\n\n    if (this.peek().type == 'else') {\n      this.advance();\n      node.alternate = this.block();\n    }\n\n    return node;\n  },\n  parseEachOf: function () {\n    var tok = this.expect('eachOf');\n    var node = {\n      type: 'EachOf',\n      obj: tok.code,\n      val: tok.val,\n      block: this.block(),\n      line: tok.loc.start.line,\n      column: tok.loc.start.column,\n      filename: this.filename\n    };\n    return node;\n  },\n\n  /**\n   * 'extends' name\n   */\n  parseExtends: function () {\n    var tok = this.expect('extends');\n    var path = this.expect('path');\n    return {\n      type: 'Extends',\n      file: {\n        type: 'FileReference',\n        path: path.val.trim(),\n        line: path.loc.start.line,\n        column: path.loc.start.column,\n        filename: this.filename\n      },\n      line: tok.loc.start.line,\n      column: tok.loc.start.column,\n      filename: this.filename\n    };\n  },\n\n  /**\n   * 'block' name block\n   */\n  parseBlock: function () {\n    var tok = this.expect('block');\n    var node = 'indent' == this.peek().type ? this.block() : this.emptyBlock(tok.loc.start.line);\n    node.type = 'NamedBlock';\n    node.name = tok.val.trim();\n    node.mode = tok.mode;\n    node.line = tok.loc.start.line;\n    node.column = tok.loc.start.column;\n    return node;\n  },\n  parseMixinBlock: function () {\n    var tok = this.expect('mixin-block');\n\n    if (!this.inMixin) {\n      this.error('BLOCK_OUTISDE_MIXIN', 'Anonymous blocks are not allowed unless they are part of a mixin.', tok);\n    }\n\n    return {\n      type: 'MixinBlock',\n      line: tok.loc.start.line,\n      column: tok.loc.start.column,\n      filename: this.filename\n    };\n  },\n  parseYield: function () {\n    var tok = this.expect('yield');\n    return {\n      type: 'YieldBlock',\n      line: tok.loc.start.line,\n      column: tok.loc.start.column,\n      filename: this.filename\n    };\n  },\n\n  /**\n   * include block?\n   */\n  parseInclude: function () {\n    var tok = this.expect('include');\n    var node = {\n      type: 'Include',\n      file: {\n        type: 'FileReference',\n        filename: this.filename\n      },\n      line: tok.loc.start.line,\n      column: tok.loc.start.column,\n      filename: this.filename\n    };\n    var filters = [];\n\n    while (this.peek().type === 'filter') {\n      filters.push(this.parseIncludeFilter());\n    }\n\n    var path = this.expect('path');\n    node.file.path = path.val.trim();\n    node.file.line = path.loc.start.line;\n    node.file.column = path.loc.start.column;\n\n    if ((/\\.jade$/.test(node.file.path) || /\\.pug$/.test(node.file.path)) && !filters.length) {\n      node.block = 'indent' == this.peek().type ? this.block() : this.emptyBlock(tok.loc.start.line);\n\n      if (/\\.jade$/.test(node.file.path)) {\n        console.warn(this.filename + ', line ' + tok.loc.start.line + ':\\nThe .jade extension is deprecated, use .pug for \"' + node.file.path + '\".');\n      }\n    } else {\n      node.type = 'RawInclude';\n      node.filters = filters;\n\n      if (this.peek().type === 'indent') {\n        this.error('RAW_INCLUDE_BLOCK', 'Raw inclusion cannot contain a block', this.peek());\n      }\n    }\n\n    return node;\n  },\n\n  /**\n   * call ident block\n   */\n  parseCall: function () {\n    var tok = this.expect('call');\n    var name = tok.val;\n    var args = tok.args;\n    var mixin = {\n      type: 'Mixin',\n      name: name,\n      args: args,\n      block: this.emptyBlock(tok.loc.start.line),\n      call: true,\n      attrs: [],\n      attributeBlocks: [],\n      line: tok.loc.start.line,\n      column: tok.loc.start.column,\n      filename: this.filename\n    };\n    this.tag(mixin);\n\n    if (mixin.code) {\n      mixin.block.nodes.push(mixin.code);\n      delete mixin.code;\n    }\n\n    if (mixin.block.nodes.length === 0) mixin.block = null;\n    return mixin;\n  },\n\n  /**\n   * mixin block\n   */\n  parseMixin: function () {\n    var tok = this.expect('mixin');\n    var name = tok.val;\n    var args = tok.args;\n\n    if ('indent' == this.peek().type) {\n      this.inMixin++;\n      var mixin = {\n        type: 'Mixin',\n        name: name,\n        args: args,\n        block: this.block(),\n        call: false,\n        line: tok.loc.start.line,\n        column: tok.loc.start.column,\n        filename: this.filename\n      };\n      this.inMixin--;\n      return mixin;\n    } else {\n      this.error('MIXIN_WITHOUT_BODY', 'Mixin ' + name + ' declared without body', tok);\n    }\n  },\n\n  /**\n   * indent (text | newline)* outdent\n   */\n  parseTextBlock: function () {\n    var tok = this.accept('start-pipeless-text');\n    if (!tok) return;\n    var block = this.emptyBlock(tok.loc.start.line);\n\n    while (this.peek().type !== 'end-pipeless-text') {\n      var tok = this.advance();\n\n      switch (tok.type) {\n        case 'text':\n          block.nodes.push({\n            type: 'Text',\n            val: tok.val,\n            line: tok.loc.start.line,\n            column: tok.loc.start.column,\n            filename: this.filename\n          });\n          break;\n\n        case 'newline':\n          block.nodes.push({\n            type: 'Text',\n            val: '\\n',\n            line: tok.loc.start.line,\n            column: tok.loc.start.column,\n            filename: this.filename\n          });\n          break;\n\n        case 'start-pug-interpolation':\n          block.nodes.push(this.parseExpr());\n          this.expect('end-pug-interpolation');\n          break;\n\n        case 'interpolated-code':\n          block.nodes.push({\n            type: 'Code',\n            val: tok.val,\n            buffer: tok.buffer,\n            mustEscape: tok.mustEscape !== false,\n            isInline: true,\n            line: tok.loc.start.line,\n            column: tok.loc.start.column,\n            filename: this.filename\n          });\n          break;\n\n        default:\n          var pluginResult = this.runPlugin('textBlockTokens', tok, block, tok);\n          if (pluginResult) break;\n          this.error('INVALID_TOKEN', 'Unexpected token type: ' + tok.type, tok);\n      }\n    }\n\n    this.advance();\n    return block;\n  },\n\n  /**\n   * indent expr* outdent\n   */\n  block: function () {\n    var tok = this.expect('indent');\n    var block = this.emptyBlock(tok.loc.start.line);\n\n    while ('outdent' != this.peek().type) {\n      if ('newline' == this.peek().type) {\n        this.advance();\n      } else if ('text-html' == this.peek().type) {\n        block.nodes = block.nodes.concat(this.parseTextHtml());\n      } else {\n        var expr = this.parseExpr();\n\n        if (expr.type === 'Block') {\n          block.nodes = block.nodes.concat(expr.nodes);\n        } else {\n          block.nodes.push(expr);\n        }\n      }\n    }\n\n    this.expect('outdent');\n    return block;\n  },\n\n  /**\n   * interpolation (attrs | class | id)* (text | code | ':')? newline* block?\n   */\n  parseInterpolation: function () {\n    var tok = this.advance();\n    var tag = {\n      type: 'InterpolatedTag',\n      expr: tok.val,\n      selfClosing: false,\n      block: this.emptyBlock(tok.loc.start.line),\n      attrs: [],\n      attributeBlocks: [],\n      isInline: false,\n      line: tok.loc.start.line,\n      column: tok.loc.start.column,\n      filename: this.filename\n    };\n    return this.tag(tag, {\n      selfClosingAllowed: true\n    });\n  },\n\n  /**\n   * tag (attrs | class | id)* (text | code | ':')? newline* block?\n   */\n  parseTag: function () {\n    var tok = this.advance();\n    var tag = {\n      type: 'Tag',\n      name: tok.val,\n      selfClosing: false,\n      block: this.emptyBlock(tok.loc.start.line),\n      attrs: [],\n      attributeBlocks: [],\n      isInline: inlineTags.indexOf(tok.val) !== -1,\n      line: tok.loc.start.line,\n      column: tok.loc.start.column,\n      filename: this.filename\n    };\n    return this.tag(tag, {\n      selfClosingAllowed: true\n    });\n  },\n\n  /**\n   * Parse tag.\n   */\n  tag: function (tag, options) {\n    var seenAttrs = false;\n    var attributeNames = [];\n    var selfClosingAllowed = options && options.selfClosingAllowed; // (attrs | class | id)*\n\n    out: while (true) {\n      switch (this.peek().type) {\n        case 'id':\n        case 'class':\n          var tok = this.advance();\n\n          if (tok.type === 'id') {\n            if (attributeNames.indexOf('id') !== -1) {\n              this.error('DUPLICATE_ID', 'Duplicate attribute \"id\" is not allowed.', tok);\n            }\n\n            attributeNames.push('id');\n          }\n\n          tag.attrs.push({\n            name: tok.type,\n            val: \"'\" + tok.val + \"'\",\n            line: tok.loc.start.line,\n            column: tok.loc.start.column,\n            filename: this.filename,\n            mustEscape: false\n          });\n          continue;\n\n        case 'start-attributes':\n          if (seenAttrs) {\n            console.warn(this.filename + ', line ' + this.peek().loc.start.line + ':\\nYou should not have pug tags with multiple attributes.');\n          }\n\n          seenAttrs = true;\n          tag.attrs = tag.attrs.concat(this.attrs(attributeNames));\n          continue;\n\n        case '&attributes':\n          var tok = this.advance();\n          tag.attributeBlocks.push({\n            type: 'AttributeBlock',\n            val: tok.val,\n            line: tok.loc.start.line,\n            column: tok.loc.start.column,\n            filename: this.filename\n          });\n          break;\n\n        default:\n          var pluginResult = this.runPlugin('tagAttributeTokens', this.peek(), tag, attributeNames);\n          if (pluginResult) break;\n          break out;\n      }\n    } // check immediate '.'\n\n\n    if ('dot' == this.peek().type) {\n      tag.textOnly = true;\n      this.advance();\n    } // (text | code | ':')?\n\n\n    switch (this.peek().type) {\n      case 'text':\n      case 'interpolated-code':\n        var text = this.parseText();\n\n        if (text.type === 'Block') {\n          tag.block.nodes.push.apply(tag.block.nodes, text.nodes);\n        } else {\n          tag.block.nodes.push(text);\n        }\n\n        break;\n\n      case 'code':\n        tag.block.nodes.push(this.parseCode(true));\n        break;\n\n      case ':':\n        this.advance();\n        var expr = this.parseExpr();\n        tag.block = expr.type === 'Block' ? expr : this.initBlock(tag.line, [expr]);\n        break;\n\n      case 'newline':\n      case 'indent':\n      case 'outdent':\n      case 'eos':\n      case 'start-pipeless-text':\n      case 'end-pug-interpolation':\n        break;\n\n      case 'slash':\n        if (selfClosingAllowed) {\n          this.advance();\n          tag.selfClosing = true;\n          break;\n        }\n\n      default:\n        var pluginResult = this.runPlugin('tagTokens', this.peek(), tag, options);\n        if (pluginResult) break;\n        this.error('INVALID_TOKEN', 'Unexpected token `' + this.peek().type + '` expected `text`, `interpolated-code`, `code`, `:`' + (selfClosingAllowed ? ', `slash`' : '') + ', `newline` or `eos`', this.peek());\n    } // newline*\n\n\n    while ('newline' == this.peek().type) this.advance(); // block?\n\n\n    if (tag.textOnly) {\n      tag.block = this.parseTextBlock() || this.emptyBlock(tag.line);\n    } else if ('indent' == this.peek().type) {\n      var block = this.block();\n\n      for (var i = 0, len = block.nodes.length; i < len; ++i) {\n        tag.block.nodes.push(block.nodes[i]);\n      }\n    }\n\n    return tag;\n  },\n  attrs: function (attributeNames) {\n    this.expect('start-attributes');\n    var attrs = [];\n    var tok = this.advance();\n\n    while (tok.type === 'attribute') {\n      if (tok.name !== 'class' && attributeNames) {\n        if (attributeNames.indexOf(tok.name) !== -1) {\n          this.error('DUPLICATE_ATTRIBUTE', 'Duplicate attribute \"' + tok.name + '\" is not allowed.', tok);\n        }\n\n        attributeNames.push(tok.name);\n      }\n\n      attrs.push({\n        name: tok.name,\n        val: tok.val,\n        line: tok.loc.start.line,\n        column: tok.loc.start.column,\n        filename: this.filename,\n        mustEscape: tok.mustEscape !== false\n      });\n      tok = this.advance();\n    }\n\n    this.tokens.defer(tok);\n    this.expect('end-attributes');\n    return attrs;\n  }\n};","map":{"version":3,"sources":["C:/Users/bekke/Documents/Art Website/node_modules/pug-parser/index.js"],"names":["assert","require","TokenStream","error","inlineTags","module","exports","parse","Parser","tokens","options","parser","ast","JSON","stringify","Array","isArray","Error","filename","src","inMixin","plugins","prototype","constructor","code","message","token","err","line","loc","start","column","advance","peek","lookahead","n","block","emptyBlock","type","nodes","concat","parseTextHtml","expr","parseExpr","push","expect","accept","initBlock","runPlugin","context","tok","rest","i","arguments","length","pluginContext","plugin","apply","parseTag","parseMixin","parseBlock","parseMixinBlock","parseCase","parseExtends","parseInclude","parseDoctype","parseFilter","parseComment","parseText","parseDot","parseEach","parseEachOf","parseCode","parseBlockCode","parseConditional","parseWhile","parseCall","parseInterpolation","parseYield","defer","val","pluginResult","parseTextBlock","tags","lineno","nextTok","loop","buffer","mustEscape","isInline","nextType","currentNode","text","isHtml","forEach","node","parseBlockExpansion","parseWhen","parseDefault","debug","noBlock","match","test","consequent","alternate","body","parseIncludeFilter","attrs","name","textToken","obj","key","path","file","trim","mode","filters","console","warn","args","mixin","call","attributeBlocks","tag","selfClosing","selfClosingAllowed","indexOf","seenAttrs","attributeNames","out","textOnly","len"],"mappings":"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","sourcesContent":["'use strict';\n\nvar assert = require('assert');\nvar TokenStream = require('token-stream');\nvar error = require('pug-error');\nvar inlineTags = require('./lib/inline-tags');\n\nmodule.exports = parse;\nmodule.exports.Parser = Parser;\nfunction parse(tokens, options) {\n  var parser = new Parser(tokens, options);\n  var ast = parser.parse();\n  return JSON.parse(JSON.stringify(ast));\n}\n\n/**\n * Initialize `Parser` with the given input `str` and `filename`.\n *\n * @param {String} str\n * @param {String} filename\n * @param {Object} options\n * @api public\n */\n\nfunction Parser(tokens, options) {\n  options = options || {};\n  if (!Array.isArray(tokens)) {\n    throw new Error(\n      'Expected tokens to be an Array but got \"' + typeof tokens + '\"'\n    );\n  }\n  if (typeof options !== 'object') {\n    throw new Error(\n      'Expected \"options\" to be an object but got \"' + typeof options + '\"'\n    );\n  }\n  this.tokens = new TokenStream(tokens);\n  this.filename = options.filename;\n  this.src = options.src;\n  this.inMixin = 0;\n  this.plugins = options.plugins || [];\n}\n\n/**\n * Parser prototype.\n */\n\nParser.prototype = {\n  /**\n   * Save original constructor\n   */\n\n  constructor: Parser,\n\n  error: function(code, message, token) {\n    var err = error(code, message, {\n      line: token.loc.start.line,\n      column: token.loc.start.column,\n      filename: this.filename,\n      src: this.src,\n    });\n    throw err;\n  },\n\n  /**\n   * Return the next token object.\n   *\n   * @return {Object}\n   * @api private\n   */\n\n  advance: function() {\n    return this.tokens.advance();\n  },\n\n  /**\n   * Single token lookahead.\n   *\n   * @return {Object}\n   * @api private\n   */\n\n  peek: function() {\n    return this.tokens.peek();\n  },\n\n  /**\n   * `n` token lookahead.\n   *\n   * @param {Number} n\n   * @return {Object}\n   * @api private\n   */\n\n  lookahead: function(n) {\n    return this.tokens.lookahead(n);\n  },\n\n  /**\n   * Parse input returning a string of js for evaluation.\n   *\n   * @return {String}\n   * @api public\n   */\n\n  parse: function() {\n    var block = this.emptyBlock(0);\n\n    while ('eos' != this.peek().type) {\n      if ('newline' == this.peek().type) {\n        this.advance();\n      } else if ('text-html' == this.peek().type) {\n        block.nodes = block.nodes.concat(this.parseTextHtml());\n      } else {\n        var expr = this.parseExpr();\n        if (expr) {\n          if (expr.type === 'Block') {\n            block.nodes = block.nodes.concat(expr.nodes);\n          } else {\n            block.nodes.push(expr);\n          }\n        }\n      }\n    }\n\n    return block;\n  },\n\n  /**\n   * Expect the given type, or throw an exception.\n   *\n   * @param {String} type\n   * @api private\n   */\n\n  expect: function(type) {\n    if (this.peek().type === type) {\n      return this.advance();\n    } else {\n      this.error(\n        'INVALID_TOKEN',\n        'expected \"' + type + '\", but got \"' + this.peek().type + '\"',\n        this.peek()\n      );\n    }\n  },\n\n  /**\n   * Accept the given `type`.\n   *\n   * @param {String} type\n   * @api private\n   */\n\n  accept: function(type) {\n    if (this.peek().type === type) {\n      return this.advance();\n    }\n  },\n\n  initBlock: function(line, nodes) {\n    /* istanbul ignore if */\n    if ((line | 0) !== line) throw new Error('`line` is not an integer');\n    /* istanbul ignore if */\n    if (!Array.isArray(nodes)) throw new Error('`nodes` is not an array');\n    return {\n      type: 'Block',\n      nodes: nodes,\n      line: line,\n      filename: this.filename,\n    };\n  },\n\n  emptyBlock: function(line) {\n    return this.initBlock(line, []);\n  },\n\n  runPlugin: function(context, tok) {\n    var rest = [this];\n    for (var i = 2; i < arguments.length; i++) {\n      rest.push(arguments[i]);\n    }\n    var pluginContext;\n    for (var i = 0; i < this.plugins.length; i++) {\n      var plugin = this.plugins[i];\n      if (plugin[context] && plugin[context][tok.type]) {\n        if (pluginContext)\n          throw new Error(\n            'Multiple plugin handlers found for context ' +\n              JSON.stringify(context) +\n              ', token type ' +\n              JSON.stringify(tok.type)\n          );\n        pluginContext = plugin[context];\n      }\n    }\n    if (pluginContext)\n      return pluginContext[tok.type].apply(pluginContext, rest);\n  },\n\n  /**\n   *   tag\n   * | doctype\n   * | mixin\n   * | include\n   * | filter\n   * | comment\n   * | text\n   * | text-html\n   * | dot\n   * | each\n   * | code\n   * | yield\n   * | id\n   * | class\n   * | interpolation\n   */\n\n  parseExpr: function() {\n    switch (this.peek().type) {\n      case 'tag':\n        return this.parseTag();\n      case 'mixin':\n        return this.parseMixin();\n      case 'block':\n        return this.parseBlock();\n      case 'mixin-block':\n        return this.parseMixinBlock();\n      case 'case':\n        return this.parseCase();\n      case 'extends':\n        return this.parseExtends();\n      case 'include':\n        return this.parseInclude();\n      case 'doctype':\n        return this.parseDoctype();\n      case 'filter':\n        return this.parseFilter();\n      case 'comment':\n        return this.parseComment();\n      case 'text':\n      case 'interpolated-code':\n      case 'start-pug-interpolation':\n        return this.parseText({block: true});\n      case 'text-html':\n        return this.initBlock(this.peek().loc.start.line, this.parseTextHtml());\n      case 'dot':\n        return this.parseDot();\n      case 'each':\n        return this.parseEach();\n      case 'eachOf':\n        return this.parseEachOf();\n      case 'code':\n        return this.parseCode();\n      case 'blockcode':\n        return this.parseBlockCode();\n      case 'if':\n        return this.parseConditional();\n      case 'while':\n        return this.parseWhile();\n      case 'call':\n        return this.parseCall();\n      case 'interpolation':\n        return this.parseInterpolation();\n      case 'yield':\n        return this.parseYield();\n      case 'id':\n      case 'class':\n        if (!this.peek().loc.start) debugger;\n        this.tokens.defer({\n          type: 'tag',\n          val: 'div',\n          loc: this.peek().loc,\n          filename: this.filename,\n        });\n        return this.parseExpr();\n      default:\n        var pluginResult = this.runPlugin('expressionTokens', this.peek());\n        if (pluginResult) return pluginResult;\n        this.error(\n          'INVALID_TOKEN',\n          'unexpected token \"' + this.peek().type + '\"',\n          this.peek()\n        );\n    }\n  },\n\n  parseDot: function() {\n    this.advance();\n    return this.parseTextBlock();\n  },\n\n  /**\n   * Text\n   */\n\n  parseText: function(options) {\n    var tags = [];\n    var lineno = this.peek().loc.start.line;\n    var nextTok = this.peek();\n    loop: while (true) {\n      switch (nextTok.type) {\n        case 'text':\n          var tok = this.advance();\n          tags.push({\n            type: 'Text',\n            val: tok.val,\n            line: tok.loc.start.line,\n            column: tok.loc.start.column,\n            filename: this.filename,\n          });\n          break;\n        case 'interpolated-code':\n          var tok = this.advance();\n          tags.push({\n            type: 'Code',\n            val: tok.val,\n            buffer: tok.buffer,\n            mustEscape: tok.mustEscape !== false,\n            isInline: true,\n            line: tok.loc.start.line,\n            column: tok.loc.start.column,\n            filename: this.filename,\n          });\n          break;\n        case 'newline':\n          if (!options || !options.block) break loop;\n          var tok = this.advance();\n          var nextType = this.peek().type;\n          if (nextType === 'text' || nextType === 'interpolated-code') {\n            tags.push({\n              type: 'Text',\n              val: '\\n',\n              line: tok.loc.start.line,\n              column: tok.loc.start.column,\n              filename: this.filename,\n            });\n          }\n          break;\n        case 'start-pug-interpolation':\n          this.advance();\n          tags.push(this.parseExpr());\n          this.expect('end-pug-interpolation');\n          break;\n        default:\n          var pluginResult = this.runPlugin('textTokens', nextTok, tags);\n          if (pluginResult) break;\n          break loop;\n      }\n      nextTok = this.peek();\n    }\n    if (tags.length === 1) return tags[0];\n    else return this.initBlock(lineno, tags);\n  },\n\n  parseTextHtml: function() {\n    var nodes = [];\n    var currentNode = null;\n    loop: while (true) {\n      switch (this.peek().type) {\n        case 'text-html':\n          var text = this.advance();\n          if (!currentNode) {\n            currentNode = {\n              type: 'Text',\n              val: text.val,\n              filename: this.filename,\n              line: text.loc.start.line,\n              column: text.loc.start.column,\n              isHtml: true,\n            };\n            nodes.push(currentNode);\n          } else {\n            currentNode.val += '\\n' + text.val;\n          }\n          break;\n        case 'indent':\n          var block = this.block();\n          block.nodes.forEach(function(node) {\n            if (node.isHtml) {\n              if (!currentNode) {\n                currentNode = node;\n                nodes.push(currentNode);\n              } else {\n                currentNode.val += '\\n' + node.val;\n              }\n            } else {\n              currentNode = null;\n              nodes.push(node);\n            }\n          });\n          break;\n        case 'code':\n          currentNode = null;\n          nodes.push(this.parseCode(true));\n          break;\n        case 'newline':\n          this.advance();\n          break;\n        default:\n          break loop;\n      }\n    }\n    return nodes;\n  },\n\n  /**\n   *   ':' expr\n   * | block\n   */\n\n  parseBlockExpansion: function() {\n    var tok = this.accept(':');\n    if (tok) {\n      var expr = this.parseExpr();\n      return expr.type === 'Block'\n        ? expr\n        : this.initBlock(tok.loc.start.line, [expr]);\n    } else {\n      return this.block();\n    }\n  },\n\n  /**\n   * case\n   */\n\n  parseCase: function() {\n    var tok = this.expect('case');\n    var node = {\n      type: 'Case',\n      expr: tok.val,\n      line: tok.loc.start.line,\n      column: tok.loc.start.column,\n      filename: this.filename,\n    };\n\n    var block = this.emptyBlock(tok.loc.start.line + 1);\n    this.expect('indent');\n    while ('outdent' != this.peek().type) {\n      switch (this.peek().type) {\n        case 'comment':\n        case 'newline':\n          this.advance();\n          break;\n        case 'when':\n          block.nodes.push(this.parseWhen());\n          break;\n        case 'default':\n          block.nodes.push(this.parseDefault());\n          break;\n        default:\n          var pluginResult = this.runPlugin('caseTokens', this.peek(), block);\n          if (pluginResult) break;\n          this.error(\n            'INVALID_TOKEN',\n            'Unexpected token \"' +\n              this.peek().type +\n              '\", expected \"when\", \"default\" or \"newline\"',\n            this.peek()\n          );\n      }\n    }\n    this.expect('outdent');\n\n    node.block = block;\n\n    return node;\n  },\n\n  /**\n   * when\n   */\n\n  parseWhen: function() {\n    var tok = this.expect('when');\n    if (this.peek().type !== 'newline') {\n      return {\n        type: 'When',\n        expr: tok.val,\n        block: this.parseBlockExpansion(),\n        debug: false,\n        line: tok.loc.start.line,\n        column: tok.loc.start.column,\n        filename: this.filename,\n      };\n    } else {\n      return {\n        type: 'When',\n        expr: tok.val,\n        debug: false,\n        line: tok.loc.start.line,\n        column: tok.loc.start.column,\n        filename: this.filename,\n      };\n    }\n  },\n\n  /**\n   * default\n   */\n\n  parseDefault: function() {\n    var tok = this.expect('default');\n    return {\n      type: 'When',\n      expr: 'default',\n      block: this.parseBlockExpansion(),\n      debug: false,\n      line: tok.loc.start.line,\n      column: tok.loc.start.column,\n      filename: this.filename,\n    };\n  },\n\n  /**\n   * code\n   */\n\n  parseCode: function(noBlock) {\n    var tok = this.expect('code');\n    assert(\n      typeof tok.mustEscape === 'boolean',\n      'Please update to the newest version of pug-lexer.'\n    );\n    var node = {\n      type: 'Code',\n      val: tok.val,\n      buffer: tok.buffer,\n      mustEscape: tok.mustEscape !== false,\n      isInline: !!noBlock,\n      line: tok.loc.start.line,\n      column: tok.loc.start.column,\n      filename: this.filename,\n    };\n    // todo: why is this here?  It seems like a hacky workaround\n    if (node.val.match(/^ *else/)) node.debug = false;\n\n    if (noBlock) return node;\n\n    var block;\n\n    // handle block\n    block = 'indent' == this.peek().type;\n    if (block) {\n      if (tok.buffer) {\n        this.error(\n          'BLOCK_IN_BUFFERED_CODE',\n          'Buffered code cannot have a block attached to it',\n          this.peek()\n        );\n      }\n      node.block = this.block();\n    }\n\n    return node;\n  },\n  parseConditional: function() {\n    var tok = this.expect('if');\n    var node = {\n      type: 'Conditional',\n      test: tok.val,\n      consequent: this.emptyBlock(tok.loc.start.line),\n      alternate: null,\n      line: tok.loc.start.line,\n      column: tok.loc.start.column,\n      filename: this.filename,\n    };\n\n    // handle block\n    if ('indent' == this.peek().type) {\n      node.consequent = this.block();\n    }\n\n    var currentNode = node;\n    while (true) {\n      if (this.peek().type === 'newline') {\n        this.expect('newline');\n      } else if (this.peek().type === 'else-if') {\n        tok = this.expect('else-if');\n        currentNode = currentNode.alternate = {\n          type: 'Conditional',\n          test: tok.val,\n          consequent: this.emptyBlock(tok.loc.start.line),\n          alternate: null,\n          line: tok.loc.start.line,\n          column: tok.loc.start.column,\n          filename: this.filename,\n        };\n        if ('indent' == this.peek().type) {\n          currentNode.consequent = this.block();\n        }\n      } else if (this.peek().type === 'else') {\n        this.expect('else');\n        if (this.peek().type === 'indent') {\n          currentNode.alternate = this.block();\n        }\n        break;\n      } else {\n        break;\n      }\n    }\n\n    return node;\n  },\n  parseWhile: function() {\n    var tok = this.expect('while');\n    var node = {\n      type: 'While',\n      test: tok.val,\n      line: tok.loc.start.line,\n      column: tok.loc.start.column,\n      filename: this.filename,\n    };\n\n    // handle block\n    if ('indent' == this.peek().type) {\n      node.block = this.block();\n    } else {\n      node.block = this.emptyBlock(tok.loc.start.line);\n    }\n\n    return node;\n  },\n\n  /**\n   * block code\n   */\n\n  parseBlockCode: function() {\n    var tok = this.expect('blockcode');\n    var line = tok.loc.start.line;\n    var column = tok.loc.start.column;\n    var body = this.peek();\n    var text = '';\n    if (body.type === 'start-pipeless-text') {\n      this.advance();\n      while (this.peek().type !== 'end-pipeless-text') {\n        tok = this.advance();\n        switch (tok.type) {\n          case 'text':\n            text += tok.val;\n            break;\n          case 'newline':\n            text += '\\n';\n            break;\n          default:\n            var pluginResult = this.runPlugin('blockCodeTokens', tok, tok);\n            if (pluginResult) {\n              text += pluginResult;\n              break;\n            }\n            this.error(\n              'INVALID_TOKEN',\n              'Unexpected token type: ' + tok.type,\n              tok\n            );\n        }\n      }\n      this.advance();\n    }\n    return {\n      type: 'Code',\n      val: text,\n      buffer: false,\n      mustEscape: false,\n      isInline: false,\n      line: line,\n      column: column,\n      filename: this.filename,\n    };\n  },\n  /**\n   * comment\n   */\n\n  parseComment: function() {\n    var tok = this.expect('comment');\n    var block;\n    if ((block = this.parseTextBlock())) {\n      return {\n        type: 'BlockComment',\n        val: tok.val,\n        block: block,\n        buffer: tok.buffer,\n        line: tok.loc.start.line,\n        column: tok.loc.start.column,\n        filename: this.filename,\n      };\n    } else {\n      return {\n        type: 'Comment',\n        val: tok.val,\n        buffer: tok.buffer,\n        line: tok.loc.start.line,\n        column: tok.loc.start.column,\n        filename: this.filename,\n      };\n    }\n  },\n\n  /**\n   * doctype\n   */\n\n  parseDoctype: function() {\n    var tok = this.expect('doctype');\n    return {\n      type: 'Doctype',\n      val: tok.val,\n      line: tok.loc.start.line,\n      column: tok.loc.start.column,\n      filename: this.filename,\n    };\n  },\n\n  parseIncludeFilter: function() {\n    var tok = this.expect('filter');\n    var attrs = [];\n\n    if (this.peek().type === 'start-attributes') {\n      attrs = this.attrs();\n    }\n\n    return {\n      type: 'IncludeFilter',\n      name: tok.val,\n      attrs: attrs,\n      line: tok.loc.start.line,\n      column: tok.loc.start.column,\n      filename: this.filename,\n    };\n  },\n\n  /**\n   * filter attrs? text-block\n   */\n\n  parseFilter: function() {\n    var tok = this.expect('filter');\n    var block,\n      attrs = [];\n\n    if (this.peek().type === 'start-attributes') {\n      attrs = this.attrs();\n    }\n\n    if (this.peek().type === 'text') {\n      var textToken = this.advance();\n      block = this.initBlock(textToken.loc.start.line, [\n        {\n          type: 'Text',\n          val: textToken.val,\n          line: textToken.loc.start.line,\n          column: textToken.loc.start.column,\n          filename: this.filename,\n        },\n      ]);\n    } else if (this.peek().type === 'filter') {\n      block = this.initBlock(tok.loc.start.line, [this.parseFilter()]);\n    } else {\n      block = this.parseTextBlock() || this.emptyBlock(tok.loc.start.line);\n    }\n\n    return {\n      type: 'Filter',\n      name: tok.val,\n      block: block,\n      attrs: attrs,\n      line: tok.loc.start.line,\n      column: tok.loc.start.column,\n      filename: this.filename,\n    };\n  },\n\n  /**\n   * each block\n   */\n\n  parseEach: function() {\n    var tok = this.expect('each');\n    var node = {\n      type: 'Each',\n      obj: tok.code,\n      val: tok.val,\n      key: tok.key,\n      block: this.block(),\n      line: tok.loc.start.line,\n      column: tok.loc.start.column,\n      filename: this.filename,\n    };\n    if (this.peek().type == 'else') {\n      this.advance();\n      node.alternate = this.block();\n    }\n    return node;\n  },\n\n  parseEachOf: function() {\n    var tok = this.expect('eachOf');\n    var node = {\n      type: 'EachOf',\n      obj: tok.code,\n      val: tok.val,\n      block: this.block(),\n      line: tok.loc.start.line,\n      column: tok.loc.start.column,\n      filename: this.filename,\n    };\n    return node;\n  },\n  /**\n   * 'extends' name\n   */\n\n  parseExtends: function() {\n    var tok = this.expect('extends');\n    var path = this.expect('path');\n    return {\n      type: 'Extends',\n      file: {\n        type: 'FileReference',\n        path: path.val.trim(),\n        line: path.loc.start.line,\n        column: path.loc.start.column,\n        filename: this.filename,\n      },\n      line: tok.loc.start.line,\n      column: tok.loc.start.column,\n      filename: this.filename,\n    };\n  },\n\n  /**\n   * 'block' name block\n   */\n\n  parseBlock: function() {\n    var tok = this.expect('block');\n\n    var node =\n      'indent' == this.peek().type\n        ? this.block()\n        : this.emptyBlock(tok.loc.start.line);\n    node.type = 'NamedBlock';\n    node.name = tok.val.trim();\n    node.mode = tok.mode;\n    node.line = tok.loc.start.line;\n    node.column = tok.loc.start.column;\n\n    return node;\n  },\n\n  parseMixinBlock: function() {\n    var tok = this.expect('mixin-block');\n    if (!this.inMixin) {\n      this.error(\n        'BLOCK_OUTISDE_MIXIN',\n        'Anonymous blocks are not allowed unless they are part of a mixin.',\n        tok\n      );\n    }\n    return {\n      type: 'MixinBlock',\n      line: tok.loc.start.line,\n      column: tok.loc.start.column,\n      filename: this.filename,\n    };\n  },\n\n  parseYield: function() {\n    var tok = this.expect('yield');\n    return {\n      type: 'YieldBlock',\n      line: tok.loc.start.line,\n      column: tok.loc.start.column,\n      filename: this.filename,\n    };\n  },\n\n  /**\n   * include block?\n   */\n\n  parseInclude: function() {\n    var tok = this.expect('include');\n    var node = {\n      type: 'Include',\n      file: {\n        type: 'FileReference',\n        filename: this.filename,\n      },\n      line: tok.loc.start.line,\n      column: tok.loc.start.column,\n      filename: this.filename,\n    };\n    var filters = [];\n    while (this.peek().type === 'filter') {\n      filters.push(this.parseIncludeFilter());\n    }\n    var path = this.expect('path');\n\n    node.file.path = path.val.trim();\n    node.file.line = path.loc.start.line;\n    node.file.column = path.loc.start.column;\n\n    if (\n      (/\\.jade$/.test(node.file.path) || /\\.pug$/.test(node.file.path)) &&\n      !filters.length\n    ) {\n      node.block =\n        'indent' == this.peek().type\n          ? this.block()\n          : this.emptyBlock(tok.loc.start.line);\n      if (/\\.jade$/.test(node.file.path)) {\n        console.warn(\n          this.filename +\n            ', line ' +\n            tok.loc.start.line +\n            ':\\nThe .jade extension is deprecated, use .pug for \"' +\n            node.file.path +\n            '\".'\n        );\n      }\n    } else {\n      node.type = 'RawInclude';\n      node.filters = filters;\n      if (this.peek().type === 'indent') {\n        this.error(\n          'RAW_INCLUDE_BLOCK',\n          'Raw inclusion cannot contain a block',\n          this.peek()\n        );\n      }\n    }\n    return node;\n  },\n\n  /**\n   * call ident block\n   */\n\n  parseCall: function() {\n    var tok = this.expect('call');\n    var name = tok.val;\n    var args = tok.args;\n    var mixin = {\n      type: 'Mixin',\n      name: name,\n      args: args,\n      block: this.emptyBlock(tok.loc.start.line),\n      call: true,\n      attrs: [],\n      attributeBlocks: [],\n      line: tok.loc.start.line,\n      column: tok.loc.start.column,\n      filename: this.filename,\n    };\n\n    this.tag(mixin);\n    if (mixin.code) {\n      mixin.block.nodes.push(mixin.code);\n      delete mixin.code;\n    }\n    if (mixin.block.nodes.length === 0) mixin.block = null;\n    return mixin;\n  },\n\n  /**\n   * mixin block\n   */\n\n  parseMixin: function() {\n    var tok = this.expect('mixin');\n    var name = tok.val;\n    var args = tok.args;\n\n    if ('indent' == this.peek().type) {\n      this.inMixin++;\n      var mixin = {\n        type: 'Mixin',\n        name: name,\n        args: args,\n        block: this.block(),\n        call: false,\n        line: tok.loc.start.line,\n        column: tok.loc.start.column,\n        filename: this.filename,\n      };\n      this.inMixin--;\n      return mixin;\n    } else {\n      this.error(\n        'MIXIN_WITHOUT_BODY',\n        'Mixin ' + name + ' declared without body',\n        tok\n      );\n    }\n  },\n\n  /**\n   * indent (text | newline)* outdent\n   */\n\n  parseTextBlock: function() {\n    var tok = this.accept('start-pipeless-text');\n    if (!tok) return;\n    var block = this.emptyBlock(tok.loc.start.line);\n    while (this.peek().type !== 'end-pipeless-text') {\n      var tok = this.advance();\n      switch (tok.type) {\n        case 'text':\n          block.nodes.push({\n            type: 'Text',\n            val: tok.val,\n            line: tok.loc.start.line,\n            column: tok.loc.start.column,\n            filename: this.filename,\n          });\n          break;\n        case 'newline':\n          block.nodes.push({\n            type: 'Text',\n            val: '\\n',\n            line: tok.loc.start.line,\n            column: tok.loc.start.column,\n            filename: this.filename,\n          });\n          break;\n        case 'start-pug-interpolation':\n          block.nodes.push(this.parseExpr());\n          this.expect('end-pug-interpolation');\n          break;\n        case 'interpolated-code':\n          block.nodes.push({\n            type: 'Code',\n            val: tok.val,\n            buffer: tok.buffer,\n            mustEscape: tok.mustEscape !== false,\n            isInline: true,\n            line: tok.loc.start.line,\n            column: tok.loc.start.column,\n            filename: this.filename,\n          });\n          break;\n        default:\n          var pluginResult = this.runPlugin('textBlockTokens', tok, block, tok);\n          if (pluginResult) break;\n          this.error(\n            'INVALID_TOKEN',\n            'Unexpected token type: ' + tok.type,\n            tok\n          );\n      }\n    }\n    this.advance();\n    return block;\n  },\n\n  /**\n   * indent expr* outdent\n   */\n\n  block: function() {\n    var tok = this.expect('indent');\n    var block = this.emptyBlock(tok.loc.start.line);\n    while ('outdent' != this.peek().type) {\n      if ('newline' == this.peek().type) {\n        this.advance();\n      } else if ('text-html' == this.peek().type) {\n        block.nodes = block.nodes.concat(this.parseTextHtml());\n      } else {\n        var expr = this.parseExpr();\n        if (expr.type === 'Block') {\n          block.nodes = block.nodes.concat(expr.nodes);\n        } else {\n          block.nodes.push(expr);\n        }\n      }\n    }\n    this.expect('outdent');\n    return block;\n  },\n\n  /**\n   * interpolation (attrs | class | id)* (text | code | ':')? newline* block?\n   */\n\n  parseInterpolation: function() {\n    var tok = this.advance();\n    var tag = {\n      type: 'InterpolatedTag',\n      expr: tok.val,\n      selfClosing: false,\n      block: this.emptyBlock(tok.loc.start.line),\n      attrs: [],\n      attributeBlocks: [],\n      isInline: false,\n      line: tok.loc.start.line,\n      column: tok.loc.start.column,\n      filename: this.filename,\n    };\n\n    return this.tag(tag, {selfClosingAllowed: true});\n  },\n\n  /**\n   * tag (attrs | class | id)* (text | code | ':')? newline* block?\n   */\n\n  parseTag: function() {\n    var tok = this.advance();\n    var tag = {\n      type: 'Tag',\n      name: tok.val,\n      selfClosing: false,\n      block: this.emptyBlock(tok.loc.start.line),\n      attrs: [],\n      attributeBlocks: [],\n      isInline: inlineTags.indexOf(tok.val) !== -1,\n      line: tok.loc.start.line,\n      column: tok.loc.start.column,\n      filename: this.filename,\n    };\n\n    return this.tag(tag, {selfClosingAllowed: true});\n  },\n\n  /**\n   * Parse tag.\n   */\n\n  tag: function(tag, options) {\n    var seenAttrs = false;\n    var attributeNames = [];\n    var selfClosingAllowed = options && options.selfClosingAllowed;\n    // (attrs | class | id)*\n    out: while (true) {\n      switch (this.peek().type) {\n        case 'id':\n        case 'class':\n          var tok = this.advance();\n          if (tok.type === 'id') {\n            if (attributeNames.indexOf('id') !== -1) {\n              this.error(\n                'DUPLICATE_ID',\n                'Duplicate attribute \"id\" is not allowed.',\n                tok\n              );\n            }\n            attributeNames.push('id');\n          }\n          tag.attrs.push({\n            name: tok.type,\n            val: \"'\" + tok.val + \"'\",\n            line: tok.loc.start.line,\n            column: tok.loc.start.column,\n            filename: this.filename,\n            mustEscape: false,\n          });\n          continue;\n        case 'start-attributes':\n          if (seenAttrs) {\n            console.warn(\n              this.filename +\n                ', line ' +\n                this.peek().loc.start.line +\n                ':\\nYou should not have pug tags with multiple attributes.'\n            );\n          }\n          seenAttrs = true;\n          tag.attrs = tag.attrs.concat(this.attrs(attributeNames));\n          continue;\n        case '&attributes':\n          var tok = this.advance();\n          tag.attributeBlocks.push({\n            type: 'AttributeBlock',\n            val: tok.val,\n            line: tok.loc.start.line,\n            column: tok.loc.start.column,\n            filename: this.filename,\n          });\n          break;\n        default:\n          var pluginResult = this.runPlugin(\n            'tagAttributeTokens',\n            this.peek(),\n            tag,\n            attributeNames\n          );\n          if (pluginResult) break;\n          break out;\n      }\n    }\n\n    // check immediate '.'\n    if ('dot' == this.peek().type) {\n      tag.textOnly = true;\n      this.advance();\n    }\n\n    // (text | code | ':')?\n    switch (this.peek().type) {\n      case 'text':\n      case 'interpolated-code':\n        var text = this.parseText();\n        if (text.type === 'Block') {\n          tag.block.nodes.push.apply(tag.block.nodes, text.nodes);\n        } else {\n          tag.block.nodes.push(text);\n        }\n        break;\n      case 'code':\n        tag.block.nodes.push(this.parseCode(true));\n        break;\n      case ':':\n        this.advance();\n        var expr = this.parseExpr();\n        tag.block =\n          expr.type === 'Block' ? expr : this.initBlock(tag.line, [expr]);\n        break;\n      case 'newline':\n      case 'indent':\n      case 'outdent':\n      case 'eos':\n      case 'start-pipeless-text':\n      case 'end-pug-interpolation':\n        break;\n      case 'slash':\n        if (selfClosingAllowed) {\n          this.advance();\n          tag.selfClosing = true;\n          break;\n        }\n      default:\n        var pluginResult = this.runPlugin(\n          'tagTokens',\n          this.peek(),\n          tag,\n          options\n        );\n        if (pluginResult) break;\n        this.error(\n          'INVALID_TOKEN',\n          'Unexpected token `' +\n            this.peek().type +\n            '` expected `text`, `interpolated-code`, `code`, `:`' +\n            (selfClosingAllowed ? ', `slash`' : '') +\n            ', `newline` or `eos`',\n          this.peek()\n        );\n    }\n\n    // newline*\n    while ('newline' == this.peek().type) this.advance();\n\n    // block?\n    if (tag.textOnly) {\n      tag.block = this.parseTextBlock() || this.emptyBlock(tag.line);\n    } else if ('indent' == this.peek().type) {\n      var block = this.block();\n      for (var i = 0, len = block.nodes.length; i < len; ++i) {\n        tag.block.nodes.push(block.nodes[i]);\n      }\n    }\n\n    return tag;\n  },\n\n  attrs: function(attributeNames) {\n    this.expect('start-attributes');\n\n    var attrs = [];\n    var tok = this.advance();\n    while (tok.type === 'attribute') {\n      if (tok.name !== 'class' && attributeNames) {\n        if (attributeNames.indexOf(tok.name) !== -1) {\n          this.error(\n            'DUPLICATE_ATTRIBUTE',\n            'Duplicate attribute \"' + tok.name + '\" is not allowed.',\n            tok\n          );\n        }\n        attributeNames.push(tok.name);\n      }\n      attrs.push({\n        name: tok.name,\n        val: tok.val,\n        line: tok.loc.start.line,\n        column: tok.loc.start.column,\n        filename: this.filename,\n        mustEscape: tok.mustEscape !== false,\n      });\n      tok = this.advance();\n    }\n    this.tokens.defer(tok);\n    this.expect('end-attributes');\n    return attrs;\n  },\n};\n"]},"metadata":{},"sourceType":"script"}