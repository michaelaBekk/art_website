{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst assert_never_1 = __importDefault(require(\"assert-never\"));\n\nconst babel_walk_1 = require(\"babel-walk\");\n\nconst t = __importStar(require(\"@babel/types\"));\n\nconst reference_1 = __importDefault(require(\"./reference\"));\n\nconst isScope = node => t.isFunctionParent(node) || t.isProgram(node);\n\nconst isBlockScope = node => t.isBlockStatement(node) || isScope(node);\n\nconst declaresArguments = node => t.isFunction(node) && !t.isArrowFunctionExpression(node);\n\nconst declaresThis = declaresArguments;\nconst LOCALS_SYMBOL = Symbol('locals');\n\nconst getLocals = node => node[LOCALS_SYMBOL];\n\nconst declareLocals = node => node[LOCALS_SYMBOL] = node[LOCALS_SYMBOL] || new Set();\n\nconst setLocal = (node, name) => declareLocals(node).add(name); // First pass\n\n\nfunction declareFunction(node) {\n  for (const param of node.params) {\n    declarePattern(param, node);\n  }\n\n  const id = node.id;\n\n  if (id) {\n    setLocal(node, id.name);\n  }\n}\n\nfunction declarePattern(node, parent) {\n  switch (node.type) {\n    case 'Identifier':\n      setLocal(parent, node.name);\n      break;\n\n    case 'ObjectPattern':\n      for (const prop of node.properties) {\n        switch (prop.type) {\n          case 'RestElement':\n            declarePattern(prop.argument, parent);\n            break;\n\n          case 'ObjectProperty':\n            declarePattern(prop.value, parent);\n            break;\n\n          default:\n            assert_never_1.default(prop);\n            break;\n        }\n      }\n\n      break;\n\n    case 'ArrayPattern':\n      for (const element of node.elements) {\n        if (element) declarePattern(element, parent);\n      }\n\n      break;\n\n    case 'RestElement':\n      declarePattern(node.argument, parent);\n      break;\n\n    case 'AssignmentPattern':\n      declarePattern(node.left, parent);\n      break;\n    // istanbul ignore next\n\n    default:\n      throw new Error('Unrecognized pattern type: ' + node.type);\n  }\n}\n\nfunction declareModuleSpecifier(node, _state, parents) {\n  for (let i = parents.length - 2; i >= 0; i--) {\n    if (isScope(parents[i])) {\n      setLocal(parents[i], node.local.name);\n      return;\n    }\n  }\n}\n\nconst firstPass = babel_walk_1.ancestor({\n  VariableDeclaration(node, _state, parents) {\n    for (let i = parents.length - 2; i >= 0; i--) {\n      if (node.kind === 'var' ? t.isFunctionParent(parents[i]) : isBlockScope(parents[i])) {\n        for (const declaration of node.declarations) {\n          declarePattern(declaration.id, parents[i]);\n        }\n\n        return;\n      }\n    }\n  },\n\n  FunctionDeclaration(node, _state, parents) {\n    if (node.id) {\n      for (let i = parents.length - 2; i >= 0; i--) {\n        if (isScope(parents[i])) {\n          setLocal(parents[i], node.id.name);\n          return;\n        }\n      }\n    }\n  },\n\n  Function: declareFunction,\n\n  ClassDeclaration(node, _state, parents) {\n    for (let i = parents.length - 2; i >= 0; i--) {\n      if (isScope(parents[i])) {\n        setLocal(parents[i], node.id.name);\n        return;\n      }\n    }\n  },\n\n  TryStatement(node) {\n    if (node.handler === null) return;\n    if (node.handler.param === null) return;\n    declarePattern(node.handler.param, node.handler);\n  },\n\n  ImportDefaultSpecifier: declareModuleSpecifier,\n  ImportSpecifier: declareModuleSpecifier,\n  ImportNamespaceSpecifier: declareModuleSpecifier\n}); // Second pass\n\nconst secondPass = babel_walk_1.ancestor({\n  Identifier(node, state, parents) {\n    var _a;\n\n    const name = node.name;\n    if (name === 'undefined') return;\n    const lastParent = parents[parents.length - 2];\n\n    if (lastParent) {\n      if (!reference_1.default(node, lastParent)) return;\n\n      for (const parent of parents) {\n        if (name === 'arguments' && declaresArguments(parent)) {\n          return;\n        }\n\n        if ((_a = getLocals(parent)) === null || _a === void 0 ? void 0 : _a.has(name)) {\n          return;\n        }\n      }\n    }\n\n    state.globals.push(node);\n  },\n\n  ThisExpression(node, state, parents) {\n    for (const parent of parents) {\n      if (declaresThis(parent)) {\n        return;\n      }\n    }\n\n    state.globals.push(node);\n  }\n\n});\n\nfunction findGlobals(ast) {\n  const globals = []; // istanbul ignore if\n\n  if (!t.isNode(ast)) {\n    throw new TypeError('Source must be a Babylon AST');\n  }\n\n  firstPass(ast, undefined);\n  secondPass(ast, {\n    globals\n  });\n  const groupedGlobals = new Map();\n\n  for (const node of globals) {\n    const name = node.type === 'ThisExpression' ? 'this' : node.name;\n    const existing = groupedGlobals.get(name);\n\n    if (existing) {\n      existing.push(node);\n    } else {\n      groupedGlobals.set(name, [node]);\n    }\n  }\n\n  return [...groupedGlobals].map(([name, nodes]) => ({\n    name,\n    nodes\n  })).sort((a, b) => a.name < b.name ? -1 : 1);\n}\n\nexports.default = findGlobals;","map":{"version":3,"sources":["../src/globals.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst assert_never_1 = __importDefault(require(\"assert-never\"));\nconst babel_walk_1 = require(\"babel-walk\");\nconst t = __importStar(require(\"@babel/types\"));\nconst reference_1 = __importDefault(require(\"./reference\"));\nconst isScope = (node) => t.isFunctionParent(node) || t.isProgram(node);\nconst isBlockScope = (node) => t.isBlockStatement(node) || isScope(node);\nconst declaresArguments = (node) => t.isFunction(node) && !t.isArrowFunctionExpression(node);\nconst declaresThis = declaresArguments;\nconst LOCALS_SYMBOL = Symbol('locals');\nconst getLocals = (node) => node[LOCALS_SYMBOL];\nconst declareLocals = (node) => (node[LOCALS_SYMBOL] = node[LOCALS_SYMBOL] || new Set());\nconst setLocal = (node, name) => declareLocals(node).add(name);\n// First pass\nfunction declareFunction(node) {\n    for (const param of node.params) {\n        declarePattern(param, node);\n    }\n    const id = node.id;\n    if (id) {\n        setLocal(node, id.name);\n    }\n}\nfunction declarePattern(node, parent) {\n    switch (node.type) {\n        case 'Identifier':\n            setLocal(parent, node.name);\n            break;\n        case 'ObjectPattern':\n            for (const prop of node.properties) {\n                switch (prop.type) {\n                    case 'RestElement':\n                        declarePattern(prop.argument, parent);\n                        break;\n                    case 'ObjectProperty':\n                        declarePattern(prop.value, parent);\n                        break;\n                    default:\n                        assert_never_1.default(prop);\n                        break;\n                }\n            }\n            break;\n        case 'ArrayPattern':\n            for (const element of node.elements) {\n                if (element)\n                    declarePattern(element, parent);\n            }\n            break;\n        case 'RestElement':\n            declarePattern(node.argument, parent);\n            break;\n        case 'AssignmentPattern':\n            declarePattern(node.left, parent);\n            break;\n        // istanbul ignore next\n        default:\n            throw new Error('Unrecognized pattern type: ' + node.type);\n    }\n}\nfunction declareModuleSpecifier(node, _state, parents) {\n    for (let i = parents.length - 2; i >= 0; i--) {\n        if (isScope(parents[i])) {\n            setLocal(parents[i], node.local.name);\n            return;\n        }\n    }\n}\nconst firstPass = babel_walk_1.ancestor({\n    VariableDeclaration(node, _state, parents) {\n        for (let i = parents.length - 2; i >= 0; i--) {\n            if (node.kind === 'var'\n                ? t.isFunctionParent(parents[i])\n                : isBlockScope(parents[i])) {\n                for (const declaration of node.declarations) {\n                    declarePattern(declaration.id, parents[i]);\n                }\n                return;\n            }\n        }\n    },\n    FunctionDeclaration(node, _state, parents) {\n        if (node.id) {\n            for (let i = parents.length - 2; i >= 0; i--) {\n                if (isScope(parents[i])) {\n                    setLocal(parents[i], node.id.name);\n                    return;\n                }\n            }\n        }\n    },\n    Function: declareFunction,\n    ClassDeclaration(node, _state, parents) {\n        for (let i = parents.length - 2; i >= 0; i--) {\n            if (isScope(parents[i])) {\n                setLocal(parents[i], node.id.name);\n                return;\n            }\n        }\n    },\n    TryStatement(node) {\n        if (node.handler === null)\n            return;\n        if (node.handler.param === null)\n            return;\n        declarePattern(node.handler.param, node.handler);\n    },\n    ImportDefaultSpecifier: declareModuleSpecifier,\n    ImportSpecifier: declareModuleSpecifier,\n    ImportNamespaceSpecifier: declareModuleSpecifier,\n});\n// Second pass\nconst secondPass = babel_walk_1.ancestor({\n    Identifier(node, state, parents) {\n        var _a;\n        const name = node.name;\n        if (name === 'undefined')\n            return;\n        const lastParent = parents[parents.length - 2];\n        if (lastParent) {\n            if (!reference_1.default(node, lastParent))\n                return;\n            for (const parent of parents) {\n                if (name === 'arguments' && declaresArguments(parent)) {\n                    return;\n                }\n                if ((_a = getLocals(parent)) === null || _a === void 0 ? void 0 : _a.has(name)) {\n                    return;\n                }\n            }\n        }\n        state.globals.push(node);\n    },\n    ThisExpression(node, state, parents) {\n        for (const parent of parents) {\n            if (declaresThis(parent)) {\n                return;\n            }\n        }\n        state.globals.push(node);\n    },\n});\nfunction findGlobals(ast) {\n    const globals = [];\n    // istanbul ignore if\n    if (!t.isNode(ast)) {\n        throw new TypeError('Source must be a Babylon AST');\n    }\n    firstPass(ast, undefined);\n    secondPass(ast, { globals });\n    const groupedGlobals = new Map();\n    for (const node of globals) {\n        const name = node.type === 'ThisExpression' ? 'this' : node.name;\n        const existing = groupedGlobals.get(name);\n        if (existing) {\n            existing.push(node);\n        }\n        else {\n            groupedGlobals.set(name, [node]);\n        }\n    }\n    return [...groupedGlobals]\n        .map(([name, nodes]) => ({ name, nodes }))\n        .sort((a, b) => (a.name < b.name ? -1 : 1));\n}\nexports.default = findGlobals;\n//# sourceMappingURL=globals.js.map"]},"metadata":{},"sourceType":"script"}