{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst parser_1 = require(\"@babel/parser\");\n\nconst babel_walk_1 = require(\"babel-walk\");\n\nconst t = __importStar(require(\"@babel/types\"));\n\nconst globals_1 = __importDefault(require(\"./globals\"));\n\nconst parseOptions = {\n  allowReturnOutsideFunction: true,\n  allowImportExportEverywhere: true\n};\n/**\n * Mimic `with` as far as possible but at compile time\n *\n * @param obj The object part of a with expression\n * @param src The body of the with expression\n * @param exclude A list of variable names to explicitly exclude\n */\n\nfunction addWith(obj, src, exclude = []) {\n  // tslint:disable-next-line: no-parameter-reassignment\n  obj = obj + ''; // tslint:disable-next-line: no-parameter-reassignment\n\n  src = src + '';\n  let ast;\n\n  try {\n    ast = parser_1.parse(src, parseOptions);\n  } catch (e) {\n    throw Object.assign(new Error('Error parsing body of the with expression'), {\n      component: 'src',\n      babylonError: e\n    });\n  }\n\n  let objAst;\n\n  try {\n    objAst = parser_1.parse(obj, parseOptions);\n  } catch (e) {\n    throw Object.assign(new Error('Error parsing object part of the with expression'), {\n      component: 'obj',\n      babylonError: e\n    });\n  }\n\n  const excludeSet = new Set(['undefined', 'this', ...exclude, ...globals_1.default(objAst).map(g => g.name)]);\n  const vars = new Set(globals_1.default(ast).map(global => global.name).filter(v => !excludeSet.has(v)));\n  if (vars.size === 0) return src;\n  let declareLocal = '';\n  let local = 'locals_for_with';\n  let result = 'result_of_with';\n\n  if (t.isValidIdentifier(obj)) {\n    local = obj;\n  } else {\n    while (vars.has(local) || excludeSet.has(local)) {\n      local += '_';\n    }\n\n    declareLocal = `var ${local} = (${obj});`;\n  }\n\n  while (vars.has(result) || excludeSet.has(result)) {\n    result += '_';\n  }\n\n  const args = ['this', ...Array.from(vars).map(v => `${JSON.stringify(v)} in ${local} ?\n        ${local}.${v} :\n        typeof ${v} !== 'undefined' ? ${v} : undefined`)];\n  const unwrapped = unwrapReturns(ast, src, result);\n  return `;\n    ${declareLocal}\n    ${unwrapped.before}\n    (function (${Array.from(vars).join(', ')}) {\n      ${unwrapped.body}\n    }.call(${args.join(', ')}));\n    ${unwrapped.after};`;\n}\n\nexports.default = addWith;\nconst unwrapReturnsVisitors = babel_walk_1.recursive({\n  Function(_node, _state, _c) {// returns in these functions are not applicable\n  },\n\n  ReturnStatement(node, state) {\n    state.hasReturn = true;\n    let value = '';\n\n    if (node.argument) {\n      value = `value: (${state.source(node.argument)})`;\n    }\n\n    state.replace(node, `return {${value}};`);\n  }\n\n});\n/**\n * Take a self calling function, and unwrap it such that return inside the function\n * results in return outside the function\n *\n * @param src    Some JavaScript code representing a self-calling function\n * @param result A temporary variable to store the result in\n */\n\nfunction unwrapReturns(ast, src, result) {\n  const charArray = src.split('');\n  const state = {\n    hasReturn: false,\n\n    source(node) {\n      return src.slice(node.start, node.end);\n    },\n\n    replace(node, str) {\n      charArray.fill('', node.start, node.end);\n      charArray[node.start] = str;\n    }\n\n  };\n  unwrapReturnsVisitors(ast, state);\n  return {\n    before: state.hasReturn ? `var ${result} = ` : '',\n    body: charArray.join(''),\n    after: state.hasReturn ? `;if (${result}) return ${result}.value` : ''\n  };\n}\n\nmodule.exports = addWith;\nmodule.exports.default = addWith;","map":{"version":3,"sources":["../src/index.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,MAAA,QAAA,GAAA,OAAA,CAAA,eAAA,CAAA;;AACA,MAAA,YAAA,GAAA,OAAA,CAAA,YAAA,CAAA;;AACA,MAAA,CAAA,GAAA,YAAA,CAAA,OAAA,CAAA,cAAA,CAAA,CAAA;;AACA,MAAA,SAAA,GAAA,eAAA,CAAA,OAAA,CAAA,WAAA,CAAA,CAAA;;AAEA,MAAM,YAAY,GAAG;AACnB,EAAA,0BAA0B,EAAE,IADT;AAEnB,EAAA,2BAA2B,EAAE;AAFV,CAArB;AAKA;;;;;;AAMG;;AACH,SAAwB,OAAxB,CACE,GADF,EAEE,GAFF,EAGE,OAAA,GAAoB,EAHtB,EAGwB;AAEtB;AACA,EAAA,GAAG,GAAG,GAAG,GAAG,EAAZ,CAHsB,CAItB;;AACA,EAAA,GAAG,GAAG,GAAG,GAAG,EAAZ;AAEA,MAAI,GAAJ;;AACA,MAAI;AACF,IAAA,GAAG,GAAG,QAAA,CAAA,KAAA,CAAM,GAAN,EAAW,YAAX,CAAN;AACD,GAFD,CAEE,OAAO,CAAP,EAAU;AACV,UAAM,MAAM,CAAC,MAAP,CACJ,IAAI,KAAJ,CAAU,2CAAV,CADI,EAEJ;AACE,MAAA,SAAS,EAAE,KADb;AAEE,MAAA,YAAY,EAAE;AAFhB,KAFI,CAAN;AAOD;;AACD,MAAI,MAAJ;;AACA,MAAI;AACF,IAAA,MAAM,GAAG,QAAA,CAAA,KAAA,CAAM,GAAN,EAAW,YAAX,CAAT;AACD,GAFD,CAEE,OAAO,CAAP,EAAU;AACV,UAAM,MAAM,CAAC,MAAP,CACJ,IAAI,KAAJ,CAAU,kDAAV,CADI,EAEJ;AACE,MAAA,SAAS,EAAE,KADb;AAEE,MAAA,YAAY,EAAE;AAFhB,KAFI,CAAN;AAOD;;AACD,QAAM,UAAU,GAAG,IAAI,GAAJ,CAAQ,CACzB,WADyB,EAEzB,MAFyB,EAGzB,GAAG,OAHsB,EAIzB,GAAG,SAAA,CAAA,OAAA,CAAO,MAAP,EAAe,GAAf,CAAoB,CAAD,IAAO,CAAC,CAAC,IAA5B,CAJsB,CAAR,CAAnB;AAOA,QAAM,IAAI,GAAG,IAAI,GAAJ,CACX,SAAA,CAAA,OAAA,CAAO,GAAP,EACG,GADH,CACQ,MAAD,IAAY,MAAM,CAAC,IAD1B,EAEG,MAFH,CAEW,CAAD,IAAO,CAAC,UAAU,CAAC,GAAX,CAAe,CAAf,CAFlB,CADW,CAAb;AAMA,MAAI,IAAI,CAAC,IAAL,KAAc,CAAlB,EAAqB,OAAO,GAAP;AAErB,MAAI,YAAY,GAAG,EAAnB;AACA,MAAI,KAAK,GAAG,iBAAZ;AACA,MAAI,MAAM,GAAG,gBAAb;;AACA,MAAI,CAAC,CAAC,iBAAF,CAAoB,GAApB,CAAJ,EAA8B;AAC5B,IAAA,KAAK,GAAG,GAAR;AACD,GAFD,MAEO;AACL,WAAO,IAAI,CAAC,GAAL,CAAS,KAAT,KAAmB,UAAU,CAAC,GAAX,CAAe,KAAf,CAA1B,EAAiD;AAC/C,MAAA,KAAK,IAAI,GAAT;AACD;;AACD,IAAA,YAAY,GAAG,OAAO,KAAK,OAAO,GAAG,IAArC;AACD;;AACD,SAAO,IAAI,CAAC,GAAL,CAAS,MAAT,KAAoB,UAAU,CAAC,GAAX,CAAe,MAAf,CAA3B,EAAmD;AACjD,IAAA,MAAM,IAAI,GAAV;AACD;;AAED,QAAM,IAAI,GAAG,CACX,MADW,EAEX,GAAG,KAAK,CAAC,IAAN,CAAW,IAAX,EAAiB,GAAjB,CACA,CAAD,IACE,GAAG,IAAI,CAAC,SAAL,CAAe,CAAf,CAAiB,OAAO,KAAK;UAC9B,KAAK,IAAI,CAAC;iBACH,CAAC,sBAAsB,CAAC,cAJlC,CAFQ,CAAb;AAUA,QAAM,SAAS,GAAG,aAAa,CAAC,GAAD,EAAM,GAAN,EAAW,MAAX,CAA/B;AAEA,SAAO;MACH,YAAY;MACZ,SAAS,CAAC,MAAM;iBACL,KAAK,CAAC,IAAN,CAAW,IAAX,EAAiB,IAAjB,CAAsB,IAAtB,CAA2B;QACpC,SAAS,CAAC,IAAI;aACT,IAAI,CAAC,IAAL,CAAU,IAAV,CAAe;MACtB,SAAS,CAAC,KAAK,GANnB;AAOD;;AAnFD,OAAA,CAAA,OAAA,GAAA,OAAA;AA0FA,MAAM,qBAAqB,GAAG,YAAA,CAAA,SAAA,CAAyB;AACrD,EAAA,QAAQ,CAAC,KAAD,EAAQ,MAAR,EAAgB,EAAhB,EAAkB,CACxB;AACD,GAHoD;;AAKrD,EAAA,eAAe,CAAC,IAAD,EAAO,KAAP,EAAY;AACzB,IAAA,KAAK,CAAC,SAAN,GAAkB,IAAlB;AACA,QAAI,KAAK,GAAG,EAAZ;;AACA,QAAI,IAAI,CAAC,QAAT,EAAmB;AACjB,MAAA,KAAK,GAAG,WAAW,KAAK,CAAC,MAAN,CAAa,IAAI,CAAC,QAAlB,CAA2B,GAA9C;AACD;;AACD,IAAA,KAAK,CAAC,OAAN,CAAc,IAAd,EAAoB,WAAW,KAAK,IAApC;AACD;;AAZoD,CAAzB,CAA9B;AAeA;;;;;;AAMG;;AACH,SAAS,aAAT,CAAuB,GAAvB,EAAoC,GAApC,EAAiD,MAAjD,EAA+D;AAC7D,QAAM,SAAS,GAAG,GAAG,CAAC,KAAJ,CAAU,EAAV,CAAlB;AAEA,QAAM,KAAK,GAAuB;AAChC,IAAA,SAAS,EAAE,KADqB;;AAEhC,IAAA,MAAM,CAAC,IAAD,EAAK;AACT,aAAO,GAAG,CAAC,KAAJ,CAAU,IAAI,CAAC,KAAf,EAAuB,IAAI,CAAC,GAA5B,CAAP;AACD,KAJ+B;;AAKhC,IAAA,OAAO,CAAC,IAAD,EAAO,GAAP,EAAU;AACf,MAAA,SAAS,CAAC,IAAV,CAAe,EAAf,EAAmB,IAAI,CAAC,KAAxB,EAAgC,IAAI,CAAC,GAArC;AACA,MAAA,SAAS,CAAC,IAAI,CAAC,KAAN,CAAT,GAAyB,GAAzB;AACD;;AAR+B,GAAlC;AAWA,EAAA,qBAAqB,CAAC,GAAD,EAAM,KAAN,CAArB;AAEA,SAAO;AACL,IAAA,MAAM,EAAE,KAAK,CAAC,SAAN,GAAkB,OAAO,MAAM,KAA/B,GAAuC,EAD1C;AAEL,IAAA,IAAI,EAAE,SAAS,CAAC,IAAV,CAAe,EAAf,CAFD;AAGL,IAAA,KAAK,EAAE,KAAK,CAAC,SAAN,GAAkB,QAAQ,MAAM,YAAY,MAAM,QAAlD,GAA6D;AAH/D,GAAP;AAKD;;AAED,MAAM,CAAC,OAAP,GAAiB,OAAjB;AACA,MAAM,CAAC,OAAP,CAAe,OAAf,GAAyB,OAAzB","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst parser_1 = require(\"@babel/parser\");\nconst babel_walk_1 = require(\"babel-walk\");\nconst t = __importStar(require(\"@babel/types\"));\nconst globals_1 = __importDefault(require(\"./globals\"));\nconst parseOptions = {\n    allowReturnOutsideFunction: true,\n    allowImportExportEverywhere: true,\n};\n/**\n * Mimic `with` as far as possible but at compile time\n *\n * @param obj The object part of a with expression\n * @param src The body of the with expression\n * @param exclude A list of variable names to explicitly exclude\n */\nfunction addWith(obj, src, exclude = []) {\n    // tslint:disable-next-line: no-parameter-reassignment\n    obj = obj + '';\n    // tslint:disable-next-line: no-parameter-reassignment\n    src = src + '';\n    let ast;\n    try {\n        ast = parser_1.parse(src, parseOptions);\n    }\n    catch (e) {\n        throw Object.assign(new Error('Error parsing body of the with expression'), {\n            component: 'src',\n            babylonError: e,\n        });\n    }\n    let objAst;\n    try {\n        objAst = parser_1.parse(obj, parseOptions);\n    }\n    catch (e) {\n        throw Object.assign(new Error('Error parsing object part of the with expression'), {\n            component: 'obj',\n            babylonError: e,\n        });\n    }\n    const excludeSet = new Set([\n        'undefined',\n        'this',\n        ...exclude,\n        ...globals_1.default(objAst).map((g) => g.name),\n    ]);\n    const vars = new Set(globals_1.default(ast)\n        .map((global) => global.name)\n        .filter((v) => !excludeSet.has(v)));\n    if (vars.size === 0)\n        return src;\n    let declareLocal = '';\n    let local = 'locals_for_with';\n    let result = 'result_of_with';\n    if (t.isValidIdentifier(obj)) {\n        local = obj;\n    }\n    else {\n        while (vars.has(local) || excludeSet.has(local)) {\n            local += '_';\n        }\n        declareLocal = `var ${local} = (${obj});`;\n    }\n    while (vars.has(result) || excludeSet.has(result)) {\n        result += '_';\n    }\n    const args = [\n        'this',\n        ...Array.from(vars).map((v) => `${JSON.stringify(v)} in ${local} ?\n        ${local}.${v} :\n        typeof ${v} !== 'undefined' ? ${v} : undefined`),\n    ];\n    const unwrapped = unwrapReturns(ast, src, result);\n    return `;\n    ${declareLocal}\n    ${unwrapped.before}\n    (function (${Array.from(vars).join(', ')}) {\n      ${unwrapped.body}\n    }.call(${args.join(', ')}));\n    ${unwrapped.after};`;\n}\nexports.default = addWith;\nconst unwrapReturnsVisitors = babel_walk_1.recursive({\n    Function(_node, _state, _c) {\n        // returns in these functions are not applicable\n    },\n    ReturnStatement(node, state) {\n        state.hasReturn = true;\n        let value = '';\n        if (node.argument) {\n            value = `value: (${state.source(node.argument)})`;\n        }\n        state.replace(node, `return {${value}};`);\n    },\n});\n/**\n * Take a self calling function, and unwrap it such that return inside the function\n * results in return outside the function\n *\n * @param src    Some JavaScript code representing a self-calling function\n * @param result A temporary variable to store the result in\n */\nfunction unwrapReturns(ast, src, result) {\n    const charArray = src.split('');\n    const state = {\n        hasReturn: false,\n        source(node) {\n            return src.slice(node.start, node.end);\n        },\n        replace(node, str) {\n            charArray.fill('', node.start, node.end);\n            charArray[node.start] = str;\n        },\n    };\n    unwrapReturnsVisitors(ast, state);\n    return {\n        before: state.hasReturn ? `var ${result} = ` : '',\n        body: charArray.join(''),\n        after: state.hasReturn ? `;if (${result}) return ${result}.value` : '',\n    };\n}\nmodule.exports = addWith;\nmodule.exports.default = addWith;\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"script"}