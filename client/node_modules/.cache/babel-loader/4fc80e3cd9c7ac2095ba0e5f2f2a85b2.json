{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst t = __importStar(require(\"@babel/types\"));\n\nif (!(Array.isArray(t.TYPES) && t.TYPES.every(t => typeof t === 'string'))) {\n  throw new Error('@babel/types TYPES does not match the expected type.');\n}\n\nconst FLIPPED_ALIAS_KEYS = t.FLIPPED_ALIAS_KEYS;\nconst TYPES = new Set(t.TYPES);\n\nif (!(FLIPPED_ALIAS_KEYS && // tslint:disable-next-line: strict-type-predicates\ntypeof FLIPPED_ALIAS_KEYS === 'object' && Object.keys(FLIPPED_ALIAS_KEYS).every(key => Array.isArray(FLIPPED_ALIAS_KEYS[key]) && // tslint:disable-next-line: strict-type-predicates\nFLIPPED_ALIAS_KEYS[key].every(v => typeof v === 'string')))) {\n  throw new Error('@babel/types FLIPPED_ALIAS_KEYS does not match the expected type.');\n}\n/**\n * This serves thre functions:\n *\n * 1. Take any \"aliases\" and explode them to refecence the concrete types\n * 2. Normalize all handlers to have an `{enter, exit}` pair, rather than raw functions\n * 3. make the enter and exit handlers arrays, so that multiple handlers can be merged\n */\n\n\nfunction explode(input) {\n  const results = {};\n\n  for (const key in input) {\n    const aliases = FLIPPED_ALIAS_KEYS[key];\n\n    if (aliases) {\n      for (const concreteKey of aliases) {\n        if (concreteKey in results) {\n          if (typeof input[key] === 'function') {\n            results[concreteKey].enter.push(input[key]);\n          } else {\n            if (input[key].enter) results[concreteKey].enter.push(input[key].enter);\n            if (input[key].exit) results[concreteKey].exit.push(input[key].exit);\n          }\n        } else {\n          if (typeof input[key] === 'function') {\n            results[concreteKey] = {\n              enter: [input[key]],\n              exit: []\n            };\n          } else {\n            results[concreteKey] = {\n              enter: input[key].enter ? [input[key].enter] : [],\n              exit: input[key].exit ? [input[key].exit] : []\n            };\n          }\n        }\n      }\n    } else if (TYPES.has(key)) {\n      if (key in results) {\n        if (typeof input[key] === 'function') {\n          results[key].enter.push(input[key]);\n        } else {\n          if (input[key].enter) results[key].enter.push(input[key].enter);\n          if (input[key].exit) results[key].exit.push(input[key].exit);\n        }\n      } else {\n        if (typeof input[key] === 'function') {\n          results[key] = {\n            enter: [input[key]],\n            exit: []\n          };\n        } else {\n          results[key] = {\n            enter: input[key].enter ? [input[key].enter] : [],\n            exit: input[key].exit ? [input[key].exit] : []\n          };\n        }\n      }\n    }\n  }\n\n  return results;\n}\n\nexports.default = explode;","map":{"version":3,"sources":["../src/explode.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,MAAA,CAAA,GAAA,YAAA,CAAA,OAAA,CAAA,cAAA,CAAA,CAAA;;AAEA,IACE,EACE,KAAK,CAAC,OAAN,CAAe,CAAS,CAAC,KAAzB,KACC,CAAS,CAAC,KAAV,CAAgB,KAAhB,CAAuB,CAAD,IAAY,OAAO,CAAP,KAAa,QAA/C,CAFH,CADF,EAKE;AACA,QAAM,IAAI,KAAJ,CAAU,sDAAV,CAAN;AACD;;AAED,MAAM,kBAAkB,GAA+B,CAAS,CAC7D,kBADH;AAEA,MAAM,KAAK,GAAG,IAAI,GAAJ,CAAiB,CAAS,CAAC,KAA3B,CAAd;;AAEA,IACE,EACE,kBAAkB,IAClB;AACA,OAAO,kBAAP,KAA8B,QAF9B,IAGA,MAAM,CAAC,IAAP,CAAY,kBAAZ,EAAgC,KAAhC,CACG,GAAD,IACE,KAAK,CAAC,OAAN,CAAc,kBAAkB,CAAC,GAAD,CAAhC,KACA;AACA,kBAAkB,CAAC,GAAD,CAAlB,CAAwB,KAAxB,CAA+B,CAAD,IAAO,OAAO,CAAP,KAAa,QAAlD,CAJJ,CAJF,CADF,EAYE;AACA,QAAM,IAAI,KAAJ,CACJ,mEADI,CAAN;AAGD;AAED;;;;;;AAMG;;;AACH,SAAwB,OAAxB,CAAgC,KAAhC,EAA0C;AACxC,QAAM,OAAO,GAAQ,EAArB;;AACA,OAAK,MAAM,GAAX,IAAkB,KAAlB,EAAyB;AACvB,UAAM,OAAO,GAAG,kBAAkB,CAAC,GAAD,CAAlC;;AACA,QAAI,OAAJ,EAAa;AACX,WAAK,MAAM,WAAX,IAA0B,OAA1B,EAAmC;AACjC,YAAI,WAAW,IAAI,OAAnB,EAA4B;AAC1B,cAAI,OAAO,KAAK,CAAC,GAAD,CAAZ,KAAsB,UAA1B,EAAsC;AACpC,YAAA,OAAO,CAAC,WAAD,CAAP,CAAqB,KAArB,CAA2B,IAA3B,CAAgC,KAAK,CAAC,GAAD,CAArC;AACD,WAFD,MAEO;AACL,gBAAI,KAAK,CAAC,GAAD,CAAL,CAAW,KAAf,EACE,OAAO,CAAC,WAAD,CAAP,CAAqB,KAArB,CAA2B,IAA3B,CAAgC,KAAK,CAAC,GAAD,CAAL,CAAW,KAA3C;AACF,gBAAI,KAAK,CAAC,GAAD,CAAL,CAAW,IAAf,EACE,OAAO,CAAC,WAAD,CAAP,CAAqB,IAArB,CAA0B,IAA1B,CAA+B,KAAK,CAAC,GAAD,CAAL,CAAW,IAA1C;AACH;AACF,SATD,MASO;AACL,cAAI,OAAO,KAAK,CAAC,GAAD,CAAZ,KAAsB,UAA1B,EAAsC;AACpC,YAAA,OAAO,CAAC,WAAD,CAAP,GAAuB;AACrB,cAAA,KAAK,EAAE,CAAC,KAAK,CAAC,GAAD,CAAN,CADc;AAErB,cAAA,IAAI,EAAE;AAFe,aAAvB;AAID,WALD,MAKO;AACL,YAAA,OAAO,CAAC,WAAD,CAAP,GAAuB;AACrB,cAAA,KAAK,EAAE,KAAK,CAAC,GAAD,CAAL,CAAW,KAAX,GAAmB,CAAC,KAAK,CAAC,GAAD,CAAL,CAAW,KAAZ,CAAnB,GAAwC,EAD1B;AAErB,cAAA,IAAI,EAAE,KAAK,CAAC,GAAD,CAAL,CAAW,IAAX,GAAkB,CAAC,KAAK,CAAC,GAAD,CAAL,CAAW,IAAZ,CAAlB,GAAsC;AAFvB,aAAvB;AAID;AACF;AACF;AACF,KAzBD,MAyBO,IAAI,KAAK,CAAC,GAAN,CAAU,GAAV,CAAJ,EAAoB;AACzB,UAAI,GAAG,IAAI,OAAX,EAAoB;AAClB,YAAI,OAAO,KAAK,CAAC,GAAD,CAAZ,KAAsB,UAA1B,EAAsC;AACpC,UAAA,OAAO,CAAC,GAAD,CAAP,CAAa,KAAb,CAAmB,IAAnB,CAAwB,KAAK,CAAC,GAAD,CAA7B;AACD,SAFD,MAEO;AACL,cAAI,KAAK,CAAC,GAAD,CAAL,CAAW,KAAf,EAAsB,OAAO,CAAC,GAAD,CAAP,CAAa,KAAb,CAAmB,IAAnB,CAAwB,KAAK,CAAC,GAAD,CAAL,CAAW,KAAnC;AACtB,cAAI,KAAK,CAAC,GAAD,CAAL,CAAW,IAAf,EAAqB,OAAO,CAAC,GAAD,CAAP,CAAa,IAAb,CAAkB,IAAlB,CAAuB,KAAK,CAAC,GAAD,CAAL,CAAW,IAAlC;AACtB;AACF,OAPD,MAOO;AACL,YAAI,OAAO,KAAK,CAAC,GAAD,CAAZ,KAAsB,UAA1B,EAAsC;AACpC,UAAA,OAAO,CAAC,GAAD,CAAP,GAAe;AACb,YAAA,KAAK,EAAE,CAAC,KAAK,CAAC,GAAD,CAAN,CADM;AAEb,YAAA,IAAI,EAAE;AAFO,WAAf;AAID,SALD,MAKO;AACL,UAAA,OAAO,CAAC,GAAD,CAAP,GAAe;AACb,YAAA,KAAK,EAAE,KAAK,CAAC,GAAD,CAAL,CAAW,KAAX,GAAmB,CAAC,KAAK,CAAC,GAAD,CAAL,CAAW,KAAZ,CAAnB,GAAwC,EADlC;AAEb,YAAA,IAAI,EAAE,KAAK,CAAC,GAAD,CAAL,CAAW,IAAX,GAAkB,CAAC,KAAK,CAAC,GAAD,CAAL,CAAW,IAAZ,CAAlB,GAAsC;AAF/B,WAAf;AAID;AACF;AACF;AACF;;AACD,SAAO,OAAP;AACD;;AArDD,OAAA,CAAA,OAAA,GAAA,OAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst t = __importStar(require(\"@babel/types\"));\nif (!(Array.isArray(t.TYPES) &&\n    t.TYPES.every((t) => typeof t === 'string'))) {\n    throw new Error('@babel/types TYPES does not match the expected type.');\n}\nconst FLIPPED_ALIAS_KEYS = t\n    .FLIPPED_ALIAS_KEYS;\nconst TYPES = new Set(t.TYPES);\nif (!(FLIPPED_ALIAS_KEYS &&\n    // tslint:disable-next-line: strict-type-predicates\n    typeof FLIPPED_ALIAS_KEYS === 'object' &&\n    Object.keys(FLIPPED_ALIAS_KEYS).every((key) => Array.isArray(FLIPPED_ALIAS_KEYS[key]) &&\n        // tslint:disable-next-line: strict-type-predicates\n        FLIPPED_ALIAS_KEYS[key].every((v) => typeof v === 'string')))) {\n    throw new Error('@babel/types FLIPPED_ALIAS_KEYS does not match the expected type.');\n}\n/**\n * This serves thre functions:\n *\n * 1. Take any \"aliases\" and explode them to refecence the concrete types\n * 2. Normalize all handlers to have an `{enter, exit}` pair, rather than raw functions\n * 3. make the enter and exit handlers arrays, so that multiple handlers can be merged\n */\nfunction explode(input) {\n    const results = {};\n    for (const key in input) {\n        const aliases = FLIPPED_ALIAS_KEYS[key];\n        if (aliases) {\n            for (const concreteKey of aliases) {\n                if (concreteKey in results) {\n                    if (typeof input[key] === 'function') {\n                        results[concreteKey].enter.push(input[key]);\n                    }\n                    else {\n                        if (input[key].enter)\n                            results[concreteKey].enter.push(input[key].enter);\n                        if (input[key].exit)\n                            results[concreteKey].exit.push(input[key].exit);\n                    }\n                }\n                else {\n                    if (typeof input[key] === 'function') {\n                        results[concreteKey] = {\n                            enter: [input[key]],\n                            exit: [],\n                        };\n                    }\n                    else {\n                        results[concreteKey] = {\n                            enter: input[key].enter ? [input[key].enter] : [],\n                            exit: input[key].exit ? [input[key].exit] : [],\n                        };\n                    }\n                }\n            }\n        }\n        else if (TYPES.has(key)) {\n            if (key in results) {\n                if (typeof input[key] === 'function') {\n                    results[key].enter.push(input[key]);\n                }\n                else {\n                    if (input[key].enter)\n                        results[key].enter.push(input[key].enter);\n                    if (input[key].exit)\n                        results[key].exit.push(input[key].exit);\n                }\n            }\n            else {\n                if (typeof input[key] === 'function') {\n                    results[key] = {\n                        enter: [input[key]],\n                        exit: [],\n                    };\n                }\n                else {\n                    results[key] = {\n                        enter: input[key].enter ? [input[key].enter] : [],\n                        exit: input[key].exit ? [input[key].exit] : [],\n                    };\n                }\n            }\n        }\n    }\n    return results;\n}\nexports.default = explode;\n//# sourceMappingURL=explode.js.map"]},"metadata":{},"sourceType":"script"}