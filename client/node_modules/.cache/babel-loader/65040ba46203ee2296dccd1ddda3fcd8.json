{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.recursive = exports.ancestor = exports.simple = void 0;\n\nconst t = __importStar(require(\"@babel/types\"));\n\nconst explode_1 = __importDefault(require(\"./explode\"));\n\nconst VISITOR_KEYS = t.VISITOR_KEYS;\n\nif (!(VISITOR_KEYS && // tslint:disable-next-line: strict-type-predicates\ntypeof VISITOR_KEYS === 'object' && Object.keys(VISITOR_KEYS).every(key => Array.isArray(VISITOR_KEYS[key]) && // tslint:disable-next-line: strict-type-predicates\nVISITOR_KEYS[key].every(v => typeof v === 'string')))) {\n  throw new Error('@babel/types VISITOR_KEYS does not match the expected type.');\n}\n\nfunction simple(visitors) {\n  const vis = explode_1.default(visitors);\n  return (node, state) => {\n    (function recurse(node) {\n      if (!node) return;\n      const visitor = vis[node.type];\n\n      if (visitor === null || visitor === void 0 ? void 0 : visitor.enter) {\n        for (const v of visitor.enter) {\n          v(node, state);\n        }\n      }\n\n      for (const key of VISITOR_KEYS[node.type] || []) {\n        const subNode = node[key];\n\n        if (Array.isArray(subNode)) {\n          for (const subSubNode of subNode) {\n            recurse(subSubNode);\n          }\n        } else {\n          recurse(subNode);\n        }\n      }\n\n      if (visitor === null || visitor === void 0 ? void 0 : visitor.exit) {\n        for (const v of visitor.exit) {\n          v(node, state);\n        }\n      }\n    })(node);\n  };\n}\n\nexports.simple = simple;\n\nfunction ancestor(visitors) {\n  const vis = explode_1.default(visitors);\n  return (node, state) => {\n    const ancestors = [];\n\n    (function recurse(node) {\n      if (!node) return;\n      const visitor = vis[node.type];\n      const isNew = node !== ancestors[ancestors.length - 1];\n      if (isNew) ancestors.push(node);\n\n      if (visitor === null || visitor === void 0 ? void 0 : visitor.enter) {\n        for (const v of visitor.enter) {\n          v(node, state, ancestors);\n        }\n      }\n\n      for (const key of VISITOR_KEYS[node.type] || []) {\n        const subNode = node[key];\n\n        if (Array.isArray(subNode)) {\n          for (const subSubNode of subNode) {\n            recurse(subSubNode);\n          }\n        } else {\n          recurse(subNode);\n        }\n      }\n\n      if (visitor === null || visitor === void 0 ? void 0 : visitor.exit) {\n        for (const v of visitor.exit) {\n          v(node, state, ancestors);\n        }\n      }\n\n      if (isNew) ancestors.pop();\n    })(node);\n  };\n}\n\nexports.ancestor = ancestor;\n\nfunction recursive(visitors) {\n  const vis = explode_1.default(visitors);\n  return (node, state) => {\n    (function recurse(node) {\n      if (!node) return;\n      const visitor = vis[node.type];\n\n      if (visitor === null || visitor === void 0 ? void 0 : visitor.enter) {\n        for (const v of visitor.enter) {\n          v(node, state, recurse);\n        }\n      } else {\n        for (const key of VISITOR_KEYS[node.type] || []) {\n          const subNode = node[key];\n\n          if (Array.isArray(subNode)) {\n            for (const subSubNode of subNode) {\n              recurse(subSubNode);\n            }\n          } else {\n            recurse(subNode);\n          }\n        }\n      }\n    })(node);\n  };\n}\n\nexports.recursive = recursive;","map":{"version":3,"sources":["../src/index.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.recursive = exports.ancestor = exports.simple = void 0;\nconst t = __importStar(require(\"@babel/types\"));\nconst explode_1 = __importDefault(require(\"./explode\"));\nconst VISITOR_KEYS = t.VISITOR_KEYS;\nif (!(VISITOR_KEYS &&\n    // tslint:disable-next-line: strict-type-predicates\n    typeof VISITOR_KEYS === 'object' &&\n    Object.keys(VISITOR_KEYS).every((key) => Array.isArray(VISITOR_KEYS[key]) &&\n        // tslint:disable-next-line: strict-type-predicates\n        VISITOR_KEYS[key].every((v) => typeof v === 'string')))) {\n    throw new Error('@babel/types VISITOR_KEYS does not match the expected type.');\n}\nfunction simple(visitors) {\n    const vis = explode_1.default(visitors);\n    return (node, state) => {\n        (function recurse(node) {\n            if (!node)\n                return;\n            const visitor = vis[node.type];\n            if (visitor === null || visitor === void 0 ? void 0 : visitor.enter) {\n                for (const v of visitor.enter) {\n                    v(node, state);\n                }\n            }\n            for (const key of VISITOR_KEYS[node.type] || []) {\n                const subNode = node[key];\n                if (Array.isArray(subNode)) {\n                    for (const subSubNode of subNode) {\n                        recurse(subSubNode);\n                    }\n                }\n                else {\n                    recurse(subNode);\n                }\n            }\n            if (visitor === null || visitor === void 0 ? void 0 : visitor.exit) {\n                for (const v of visitor.exit) {\n                    v(node, state);\n                }\n            }\n        })(node);\n    };\n}\nexports.simple = simple;\nfunction ancestor(visitors) {\n    const vis = explode_1.default(visitors);\n    return (node, state) => {\n        const ancestors = [];\n        (function recurse(node) {\n            if (!node)\n                return;\n            const visitor = vis[node.type];\n            const isNew = node !== ancestors[ancestors.length - 1];\n            if (isNew)\n                ancestors.push(node);\n            if (visitor === null || visitor === void 0 ? void 0 : visitor.enter) {\n                for (const v of visitor.enter) {\n                    v(node, state, ancestors);\n                }\n            }\n            for (const key of VISITOR_KEYS[node.type] || []) {\n                const subNode = node[key];\n                if (Array.isArray(subNode)) {\n                    for (const subSubNode of subNode) {\n                        recurse(subSubNode);\n                    }\n                }\n                else {\n                    recurse(subNode);\n                }\n            }\n            if (visitor === null || visitor === void 0 ? void 0 : visitor.exit) {\n                for (const v of visitor.exit) {\n                    v(node, state, ancestors);\n                }\n            }\n            if (isNew)\n                ancestors.pop();\n        })(node);\n    };\n}\nexports.ancestor = ancestor;\nfunction recursive(visitors) {\n    const vis = explode_1.default(visitors);\n    return (node, state) => {\n        (function recurse(node) {\n            if (!node)\n                return;\n            const visitor = vis[node.type];\n            if (visitor === null || visitor === void 0 ? void 0 : visitor.enter) {\n                for (const v of visitor.enter) {\n                    v(node, state, recurse);\n                }\n            }\n            else {\n                for (const key of VISITOR_KEYS[node.type] || []) {\n                    const subNode = node[key];\n                    if (Array.isArray(subNode)) {\n                        for (const subSubNode of subNode) {\n                            recurse(subSubNode);\n                        }\n                    }\n                    else {\n                        recurse(subNode);\n                    }\n                }\n            }\n        })(node);\n    };\n}\nexports.recursive = recursive;\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"script"}