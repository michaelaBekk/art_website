{"ast":null,"code":"'use strict';\n\nvar dirname = require('path').dirname;\n\nvar constantinople = require('constantinople');\n\nvar walk = require('pug-walk');\n\nvar error = require('pug-error');\n\nvar runFilter = require('./run-filter');\n\nmodule.exports = handleFilters;\n\nfunction handleFilters(ast, filters, options, filterAliases) {\n  options = options || {};\n  walk(ast, function (node) {\n    var dir = node.filename ? dirname(node.filename) : null;\n\n    if (node.type === 'Filter') {\n      handleNestedFilters(node, filters, options, filterAliases);\n      var text = getBodyAsText(node);\n      var attrs = getAttributes(node, options);\n      attrs.filename = node.filename;\n      node.type = 'Text';\n      node.val = filterWithFallback(node, text, attrs);\n    } else if (node.type === 'RawInclude' && node.filters.length) {\n      var firstFilter = node.filters.pop();\n      var attrs = getAttributes(firstFilter, options);\n      var filename = attrs.filename = node.file.fullPath;\n      node.type = 'Text';\n      node.val = filterFileWithFallback(firstFilter, filename, node.file, attrs);\n      node.filters.slice().reverse().forEach(function (filter) {\n        var attrs = getAttributes(filter, options);\n        attrs.filename = filename;\n        node.val = filterWithFallback(filter, node.val, attrs);\n      });\n      node.filters = undefined;\n      node.file = undefined;\n    }\n\n    function filterWithFallback(filter, text, attrs, funcName) {\n      try {\n        var filterName = getFilterName(filter);\n\n        if (filters && filters[filterName]) {\n          return filters[filterName](text, attrs);\n        } else {\n          return runFilter(filterName, text, attrs, dir, funcName);\n        }\n      } catch (ex) {\n        if (ex.code === 'UNKNOWN_FILTER') {\n          throw error(ex.code, ex.message, filter);\n        }\n\n        throw ex;\n      }\n    }\n\n    function filterFileWithFallback(filter, filename, file, attrs) {\n      var filterName = getFilterName(filter);\n\n      if (filters && filters[filterName]) {\n        if (filters[filterName].renderBuffer) {\n          return filters[filterName].renderBuffer(file.raw, attrs);\n        } else {\n          return filters[filterName](file.str, attrs);\n        }\n      } else {\n        return filterWithFallback(filter, filename, attrs, 'renderFile');\n      }\n    }\n  }, {\n    includeDependencies: true\n  });\n\n  function getFilterName(filter) {\n    var filterName = filter.name;\n\n    if (filterAliases && filterAliases[filterName]) {\n      filterName = filterAliases[filterName];\n\n      if (filterAliases[filterName]) {\n        throw error('FILTER_ALISE_CHAIN', 'The filter \"' + filter.name + '\" is an alias for \"' + filterName + '\", which is an alias for \"' + filterAliases[filterName] + '\".  Pug does not support chains of filter aliases.', filter);\n      }\n    }\n\n    return filterName;\n  }\n\n  return ast;\n}\n\nfunction handleNestedFilters(node, filters, options, filterAliases) {\n  if (node.block.nodes[0] && node.block.nodes[0].type === 'Filter') {\n    node.block.nodes[0] = handleFilters(node.block, filters, options, filterAliases).nodes[0];\n  }\n}\n\nfunction getBodyAsText(node) {\n  return node.block.nodes.map(function (node) {\n    return node.val;\n  }).join('');\n}\n\nfunction getAttributes(node, options) {\n  var attrs = {};\n  node.attrs.forEach(function (attr) {\n    try {\n      attrs[attr.name] = attr.val === true ? true : constantinople.toConstant(attr.val);\n    } catch (ex) {\n      if (/not constant/.test(ex.message)) {\n        throw error('FILTER_OPTION_NOT_CONSTANT', ex.message + ' All filters are rendered compile-time so filter options must be constants.', node);\n      }\n\n      throw ex;\n    }\n  });\n  var opts = options[node.name] || {};\n  Object.keys(opts).forEach(function (opt) {\n    if (!attrs.hasOwnProperty(opt)) {\n      attrs[opt] = opts[opt];\n    }\n  });\n  return attrs;\n}","map":{"version":3,"sources":["C:/Users/bekke/Documents/Art Website/node_modules/pug-filters/lib/handle-filters.js"],"names":["dirname","require","constantinople","walk","error","runFilter","module","exports","handleFilters","ast","filters","options","filterAliases","node","dir","filename","type","handleNestedFilters","text","getBodyAsText","attrs","getAttributes","val","filterWithFallback","length","firstFilter","pop","file","fullPath","filterFileWithFallback","slice","reverse","forEach","filter","undefined","funcName","filterName","getFilterName","ex","code","message","renderBuffer","raw","str","includeDependencies","name","block","nodes","map","join","attr","toConstant","test","opts","Object","keys","opt","hasOwnProperty"],"mappings":"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","sourcesContent":["'use strict';\n\nvar dirname = require('path').dirname;\nvar constantinople = require('constantinople');\nvar walk = require('pug-walk');\nvar error = require('pug-error');\nvar runFilter = require('./run-filter');\n\nmodule.exports = handleFilters;\nfunction handleFilters(ast, filters, options, filterAliases) {\n  options = options || {};\n  walk(\n    ast,\n    function(node) {\n      var dir = node.filename ? dirname(node.filename) : null;\n      if (node.type === 'Filter') {\n        handleNestedFilters(node, filters, options, filterAliases);\n        var text = getBodyAsText(node);\n        var attrs = getAttributes(node, options);\n        attrs.filename = node.filename;\n        node.type = 'Text';\n        node.val = filterWithFallback(node, text, attrs);\n      } else if (node.type === 'RawInclude' && node.filters.length) {\n        var firstFilter = node.filters.pop();\n        var attrs = getAttributes(firstFilter, options);\n        var filename = (attrs.filename = node.file.fullPath);\n        node.type = 'Text';\n        node.val = filterFileWithFallback(\n          firstFilter,\n          filename,\n          node.file,\n          attrs\n        );\n        node.filters\n          .slice()\n          .reverse()\n          .forEach(function(filter) {\n            var attrs = getAttributes(filter, options);\n            attrs.filename = filename;\n            node.val = filterWithFallback(filter, node.val, attrs);\n          });\n        node.filters = undefined;\n        node.file = undefined;\n      }\n\n      function filterWithFallback(filter, text, attrs, funcName) {\n        try {\n          var filterName = getFilterName(filter);\n          if (filters && filters[filterName]) {\n            return filters[filterName](text, attrs);\n          } else {\n            return runFilter(filterName, text, attrs, dir, funcName);\n          }\n        } catch (ex) {\n          if (ex.code === 'UNKNOWN_FILTER') {\n            throw error(ex.code, ex.message, filter);\n          }\n          throw ex;\n        }\n      }\n\n      function filterFileWithFallback(filter, filename, file, attrs) {\n        var filterName = getFilterName(filter);\n        if (filters && filters[filterName]) {\n          if (filters[filterName].renderBuffer) {\n            return filters[filterName].renderBuffer(file.raw, attrs);\n          } else {\n            return filters[filterName](file.str, attrs);\n          }\n        } else {\n          return filterWithFallback(filter, filename, attrs, 'renderFile');\n        }\n      }\n    },\n    {includeDependencies: true}\n  );\n  function getFilterName(filter) {\n    var filterName = filter.name;\n    if (filterAliases && filterAliases[filterName]) {\n      filterName = filterAliases[filterName];\n      if (filterAliases[filterName]) {\n        throw error(\n          'FILTER_ALISE_CHAIN',\n          'The filter \"' +\n            filter.name +\n            '\" is an alias for \"' +\n            filterName +\n            '\", which is an alias for \"' +\n            filterAliases[filterName] +\n            '\".  Pug does not support chains of filter aliases.',\n          filter\n        );\n      }\n    }\n    return filterName;\n  }\n  return ast;\n}\n\nfunction handleNestedFilters(node, filters, options, filterAliases) {\n  if (node.block.nodes[0] && node.block.nodes[0].type === 'Filter') {\n    node.block.nodes[0] = handleFilters(\n      node.block,\n      filters,\n      options,\n      filterAliases\n    ).nodes[0];\n  }\n}\n\nfunction getBodyAsText(node) {\n  return node.block.nodes\n    .map(function(node) {\n      return node.val;\n    })\n    .join('');\n}\n\nfunction getAttributes(node, options) {\n  var attrs = {};\n  node.attrs.forEach(function(attr) {\n    try {\n      attrs[attr.name] =\n        attr.val === true ? true : constantinople.toConstant(attr.val);\n    } catch (ex) {\n      if (/not constant/.test(ex.message)) {\n        throw error(\n          'FILTER_OPTION_NOT_CONSTANT',\n          ex.message +\n            ' All filters are rendered compile-time so filter options must be constants.',\n          node\n        );\n      }\n      throw ex;\n    }\n  });\n  var opts = options[node.name] || {};\n  Object.keys(opts).forEach(function(opt) {\n    if (!attrs.hasOwnProperty(opt)) {\n      attrs[opt] = opts[opt];\n    }\n  });\n  return attrs;\n}\n"]},"metadata":{},"sourceType":"script"}