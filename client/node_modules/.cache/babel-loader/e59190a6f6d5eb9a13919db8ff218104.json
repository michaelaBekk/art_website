{"ast":null,"code":"'use strict';\n\nvar assert = require('assert');\n\nvar isExpression = require('is-expression');\n\nvar characterParser = require('character-parser');\n\nvar error = require('pug-error');\n\nmodule.exports = lex;\nmodule.exports.Lexer = Lexer;\n\nfunction lex(str, options) {\n  var lexer = new Lexer(str, options);\n  return JSON.parse(JSON.stringify(lexer.getTokens()));\n}\n/**\n * Initialize `Lexer` with the given `str`.\n *\n * @param {String} str\n * @param {String} filename\n * @api private\n */\n\n\nfunction Lexer(str, options) {\n  options = options || {};\n\n  if (typeof str !== 'string') {\n    throw new Error('Expected source code to be a string but got \"' + typeof str + '\"');\n  }\n\n  if (typeof options !== 'object') {\n    throw new Error('Expected \"options\" to be an object but got \"' + typeof options + '\"');\n  } //Strip any UTF-8 BOM off of the start of `str`, if it exists.\n\n\n  str = str.replace(/^\\uFEFF/, '');\n  this.input = str.replace(/\\r\\n|\\r/g, '\\n');\n  this.originalInput = this.input;\n  this.filename = options.filename;\n  this.interpolated = options.interpolated || false;\n  this.lineno = options.startingLine || 1;\n  this.colno = options.startingColumn || 1;\n  this.plugins = options.plugins || [];\n  this.indentStack = [0];\n  this.indentRe = null; // If #{}, !{} or #[] syntax is allowed when adding text\n\n  this.interpolationAllowed = true;\n  this.whitespaceRe = /[ \\n\\t]/;\n  this.tokens = [];\n  this.ended = false;\n}\n/**\n * Lexer prototype.\n */\n\n\nLexer.prototype = {\n  constructor: Lexer,\n  error: function (code, message) {\n    var err = error(code, message, {\n      line: this.lineno,\n      column: this.colno,\n      filename: this.filename,\n      src: this.originalInput\n    });\n    throw err;\n  },\n  assert: function (value, message) {\n    if (!value) this.error('ASSERT_FAILED', message);\n  },\n  isExpression: function (exp) {\n    return isExpression(exp, {\n      throw: true\n    });\n  },\n  assertExpression: function (exp, noThrow) {\n    //this verifies that a JavaScript expression is valid\n    try {\n      this.callLexerFunction('isExpression', exp);\n      return true;\n    } catch (ex) {\n      if (noThrow) return false; // not coming from acorn\n\n      if (!ex.loc) throw ex;\n      this.incrementLine(ex.loc.line - 1);\n      this.incrementColumn(ex.loc.column);\n      var msg = 'Syntax Error: ' + ex.message.replace(/ \\([0-9]+:[0-9]+\\)$/, '');\n      this.error('SYNTAX_ERROR', msg);\n    }\n  },\n  assertNestingCorrect: function (exp) {\n    //this verifies that code is properly nested, but allows\n    //invalid JavaScript such as the contents of `attributes`\n    var res = characterParser(exp);\n\n    if (res.isNesting()) {\n      this.error('INCORRECT_NESTING', 'Nesting must match on expression `' + exp + '`');\n    }\n  },\n\n  /**\n   * Construct a token with the given `type` and `val`.\n   *\n   * @param {String} type\n   * @param {String} val\n   * @return {Object}\n   * @api private\n   */\n  tok: function (type, val) {\n    var res = {\n      type: type,\n      loc: {\n        start: {\n          line: this.lineno,\n          column: this.colno\n        },\n        filename: this.filename\n      }\n    };\n    if (val !== undefined) res.val = val;\n    return res;\n  },\n\n  /**\n   * Set the token's `loc.end` value.\n   *\n   * @param {Object} tok\n   * @returns {Object}\n   * @api private\n   */\n  tokEnd: function (tok) {\n    tok.loc.end = {\n      line: this.lineno,\n      column: this.colno\n    };\n    return tok;\n  },\n\n  /**\n   * Increment `this.lineno` and reset `this.colno`.\n   *\n   * @param {Number} increment\n   * @api private\n   */\n  incrementLine: function (increment) {\n    this.lineno += increment;\n    if (increment) this.colno = 1;\n  },\n\n  /**\n   * Increment `this.colno`.\n   *\n   * @param {Number} increment\n   * @api private\n   */\n  incrementColumn: function (increment) {\n    this.colno += increment;\n  },\n\n  /**\n   * Consume the given `len` of input.\n   *\n   * @param {Number} len\n   * @api private\n   */\n  consume: function (len) {\n    this.input = this.input.substr(len);\n  },\n\n  /**\n   * Scan for `type` with the given `regexp`.\n   *\n   * @param {String} type\n   * @param {RegExp} regexp\n   * @return {Object}\n   * @api private\n   */\n  scan: function (regexp, type) {\n    var captures;\n\n    if (captures = regexp.exec(this.input)) {\n      var len = captures[0].length;\n      var val = captures[1];\n      var diff = len - (val ? val.length : 0);\n      var tok = this.tok(type, val);\n      this.consume(len);\n      this.incrementColumn(diff);\n      return tok;\n    }\n  },\n  scanEndOfLine: function (regexp, type) {\n    var captures;\n\n    if (captures = regexp.exec(this.input)) {\n      var whitespaceLength = 0;\n      var whitespace;\n      var tok;\n\n      if (whitespace = /^([ ]+)([^ ]*)/.exec(captures[0])) {\n        whitespaceLength = whitespace[1].length;\n        this.incrementColumn(whitespaceLength);\n      }\n\n      var newInput = this.input.substr(captures[0].length);\n\n      if (newInput[0] === ':') {\n        this.input = newInput;\n        tok = this.tok(type, captures[1]);\n        this.incrementColumn(captures[0].length - whitespaceLength);\n        return tok;\n      }\n\n      if (/^[ \\t]*(\\n|$)/.test(newInput)) {\n        this.input = newInput.substr(/^[ \\t]*/.exec(newInput)[0].length);\n        tok = this.tok(type, captures[1]);\n        this.incrementColumn(captures[0].length - whitespaceLength);\n        return tok;\n      }\n    }\n  },\n\n  /**\n   * Return the indexOf `(` or `{` or `[` / `)` or `}` or `]` delimiters.\n   *\n   * Make sure that when calling this function, colno is at the character\n   * immediately before the beginning.\n   *\n   * @return {Number}\n   * @api private\n   */\n  bracketExpression: function (skip) {\n    skip = skip || 0;\n    var start = this.input[skip];\n    assert(start === '(' || start === '{' || start === '[', 'The start character should be \"(\", \"{\" or \"[\"');\n    var end = characterParser.BRACKETS[start];\n    var range;\n\n    try {\n      range = characterParser.parseUntil(this.input, end, {\n        start: skip + 1\n      });\n    } catch (ex) {\n      if (ex.index !== undefined) {\n        var idx = ex.index; // starting from this.input[skip]\n\n        var tmp = this.input.substr(skip).indexOf('\\n'); // starting from this.input[0]\n\n        var nextNewline = tmp + skip;\n        var ptr = 0;\n\n        while (idx > nextNewline && tmp !== -1) {\n          this.incrementLine(1);\n          idx -= nextNewline + 1;\n          ptr += nextNewline + 1;\n          tmp = nextNewline = this.input.substr(ptr).indexOf('\\n');\n        }\n\n        this.incrementColumn(idx);\n      }\n\n      if (ex.code === 'CHARACTER_PARSER:END_OF_STRING_REACHED') {\n        this.error('NO_END_BRACKET', 'The end of the string reached with no closing bracket ' + end + ' found.');\n      } else if (ex.code === 'CHARACTER_PARSER:MISMATCHED_BRACKET') {\n        this.error('BRACKET_MISMATCH', ex.message);\n      }\n\n      throw ex;\n    }\n\n    return range;\n  },\n  scanIndentation: function () {\n    var captures, re; // established regexp\n\n    if (this.indentRe) {\n      captures = this.indentRe.exec(this.input); // determine regexp\n    } else {\n      // tabs\n      re = /^\\n(\\t*) */;\n      captures = re.exec(this.input); // spaces\n\n      if (captures && !captures[1].length) {\n        re = /^\\n( *)/;\n        captures = re.exec(this.input);\n      } // established\n\n\n      if (captures && captures[1].length) this.indentRe = re;\n    }\n\n    return captures;\n  },\n\n  /**\n   * end-of-source.\n   */\n  eos: function () {\n    if (this.input.length) return;\n\n    if (this.interpolated) {\n      this.error('NO_END_BRACKET', 'End of line was reached with no closing bracket for interpolation.');\n    }\n\n    for (var i = 0; this.indentStack[i]; i++) {\n      this.tokens.push(this.tokEnd(this.tok('outdent')));\n    }\n\n    this.tokens.push(this.tokEnd(this.tok('eos')));\n    this.ended = true;\n    return true;\n  },\n\n  /**\n   * Blank line.\n   */\n  blank: function () {\n    var captures;\n\n    if (captures = /^\\n[ \\t]*\\n/.exec(this.input)) {\n      this.consume(captures[0].length - 1);\n      this.incrementLine(1);\n      return true;\n    }\n  },\n\n  /**\n   * Comment.\n   */\n  comment: function () {\n    var captures;\n\n    if (captures = /^\\/\\/(-)?([^\\n]*)/.exec(this.input)) {\n      this.consume(captures[0].length);\n      var tok = this.tok('comment', captures[2]);\n      tok.buffer = '-' != captures[1];\n      this.interpolationAllowed = tok.buffer;\n      this.tokens.push(tok);\n      this.incrementColumn(captures[0].length);\n      this.tokEnd(tok);\n      this.callLexerFunction('pipelessText');\n      return true;\n    }\n  },\n\n  /**\n   * Interpolated tag.\n   */\n  interpolation: function () {\n    if (/^#\\{/.test(this.input)) {\n      var match = this.bracketExpression(1);\n      this.consume(match.end + 1);\n      var tok = this.tok('interpolation', match.src);\n      this.tokens.push(tok);\n      this.incrementColumn(2); // '#{'\n\n      this.assertExpression(match.src);\n      var splitted = match.src.split('\\n');\n      var lines = splitted.length - 1;\n      this.incrementLine(lines);\n      this.incrementColumn(splitted[lines].length + 1); // + 1 â†’ '}'\n\n      this.tokEnd(tok);\n      return true;\n    }\n  },\n\n  /**\n   * Tag.\n   */\n  tag: function () {\n    var captures;\n\n    if (captures = /^(\\w(?:[-:\\w]*\\w)?)/.exec(this.input)) {\n      var tok,\n          name = captures[1],\n          len = captures[0].length;\n      this.consume(len);\n      tok = this.tok('tag', name);\n      this.tokens.push(tok);\n      this.incrementColumn(len);\n      this.tokEnd(tok);\n      return true;\n    }\n  },\n\n  /**\n   * Filter.\n   */\n  filter: function (opts) {\n    var tok = this.scan(/^:([\\w\\-]+)/, 'filter');\n    var inInclude = opts && opts.inInclude;\n\n    if (tok) {\n      this.tokens.push(tok);\n      this.incrementColumn(tok.val.length);\n      this.tokEnd(tok);\n      this.callLexerFunction('attrs');\n\n      if (!inInclude) {\n        this.interpolationAllowed = false;\n        this.callLexerFunction('pipelessText');\n      }\n\n      return true;\n    }\n  },\n\n  /**\n   * Doctype.\n   */\n  doctype: function () {\n    var node = this.scanEndOfLine(/^doctype *([^\\n]*)/, 'doctype');\n\n    if (node) {\n      this.tokens.push(this.tokEnd(node));\n      return true;\n    }\n  },\n\n  /**\n   * Id.\n   */\n  id: function () {\n    var tok = this.scan(/^#([\\w-]+)/, 'id');\n\n    if (tok) {\n      this.tokens.push(tok);\n      this.incrementColumn(tok.val.length);\n      this.tokEnd(tok);\n      return true;\n    }\n\n    if (/^#/.test(this.input)) {\n      this.error('INVALID_ID', '\"' + /.[^ \\t\\(\\#\\.\\:]*/.exec(this.input.substr(1))[0] + '\" is not a valid ID.');\n    }\n  },\n\n  /**\n   * Class.\n   */\n  className: function () {\n    var tok = this.scan(/^\\.([_a-z0-9\\-]*[_a-z][_a-z0-9\\-]*)/i, 'class');\n\n    if (tok) {\n      this.tokens.push(tok);\n      this.incrementColumn(tok.val.length);\n      this.tokEnd(tok);\n      return true;\n    }\n\n    if (/^\\.[_a-z0-9\\-]+/i.test(this.input)) {\n      this.error('INVALID_CLASS_NAME', 'Class names must contain at least one letter or underscore.');\n    }\n\n    if (/^\\./.test(this.input)) {\n      this.error('INVALID_CLASS_NAME', '\"' + /.[^ \\t\\(\\#\\.\\:]*/.exec(this.input.substr(1))[0] + '\" is not a valid class name.  Class names can only contain \"_\", \"-\", a-z and 0-9, and must contain at least one of \"_\", or a-z');\n    }\n  },\n\n  /**\n   * Text.\n   */\n  endInterpolation: function () {\n    if (this.interpolated && this.input[0] === ']') {\n      this.input = this.input.substr(1);\n      this.ended = true;\n      return true;\n    }\n  },\n  addText: function (type, value, prefix, escaped) {\n    var tok;\n    if (value + prefix === '') return;\n    prefix = prefix || '';\n    escaped = escaped || 0;\n    var indexOfEnd = this.interpolated ? value.indexOf(']') : -1;\n    var indexOfStart = this.interpolationAllowed ? value.indexOf('#[') : -1;\n    var indexOfEscaped = this.interpolationAllowed ? value.indexOf('\\\\#[') : -1;\n    var matchOfStringInterp = /(\\\\)?([#!]){((?:.|\\n)*)$/.exec(value);\n    var indexOfStringInterp = this.interpolationAllowed && matchOfStringInterp ? matchOfStringInterp.index : Infinity;\n    if (indexOfEnd === -1) indexOfEnd = Infinity;\n    if (indexOfStart === -1) indexOfStart = Infinity;\n    if (indexOfEscaped === -1) indexOfEscaped = Infinity;\n\n    if (indexOfEscaped !== Infinity && indexOfEscaped < indexOfEnd && indexOfEscaped < indexOfStart && indexOfEscaped < indexOfStringInterp) {\n      prefix = prefix + value.substring(0, indexOfEscaped) + '#[';\n      return this.addText(type, value.substring(indexOfEscaped + 3), prefix, escaped + 1);\n    }\n\n    if (indexOfStart !== Infinity && indexOfStart < indexOfEnd && indexOfStart < indexOfEscaped && indexOfStart < indexOfStringInterp) {\n      tok = this.tok(type, prefix + value.substring(0, indexOfStart));\n      this.incrementColumn(prefix.length + indexOfStart + escaped);\n      this.tokens.push(this.tokEnd(tok));\n      tok = this.tok('start-pug-interpolation');\n      this.incrementColumn(2);\n      this.tokens.push(this.tokEnd(tok));\n      var child = new this.constructor(value.substr(indexOfStart + 2), {\n        filename: this.filename,\n        interpolated: true,\n        startingLine: this.lineno,\n        startingColumn: this.colno\n      });\n      var interpolated;\n\n      try {\n        interpolated = child.getTokens();\n      } catch (ex) {\n        if (ex.code && /^PUG:/.test(ex.code)) {\n          this.colno = ex.column;\n          this.error(ex.code.substr(4), ex.msg);\n        }\n\n        throw ex;\n      }\n\n      this.colno = child.colno;\n      this.tokens = this.tokens.concat(interpolated);\n      tok = this.tok('end-pug-interpolation');\n      this.incrementColumn(1);\n      this.tokens.push(this.tokEnd(tok));\n      this.addText(type, child.input);\n      return;\n    }\n\n    if (indexOfEnd !== Infinity && indexOfEnd < indexOfStart && indexOfEnd < indexOfEscaped && indexOfEnd < indexOfStringInterp) {\n      if (prefix + value.substring(0, indexOfEnd)) {\n        this.addText(type, value.substring(0, indexOfEnd), prefix);\n      }\n\n      this.ended = true;\n      this.input = value.substr(value.indexOf(']') + 1) + this.input;\n      return;\n    }\n\n    if (indexOfStringInterp !== Infinity) {\n      if (matchOfStringInterp[1]) {\n        prefix = prefix + value.substring(0, indexOfStringInterp) + '#{';\n        return this.addText(type, value.substring(indexOfStringInterp + 3), prefix, escaped + 1);\n      }\n\n      var before = value.substr(0, indexOfStringInterp);\n\n      if (prefix || before) {\n        before = prefix + before;\n        tok = this.tok(type, before);\n        this.incrementColumn(before.length + escaped);\n        this.tokens.push(this.tokEnd(tok));\n      }\n\n      var rest = matchOfStringInterp[3];\n      var range;\n      tok = this.tok('interpolated-code');\n      this.incrementColumn(2);\n\n      try {\n        range = characterParser.parseUntil(rest, '}');\n      } catch (ex) {\n        if (ex.index !== undefined) {\n          this.incrementColumn(ex.index);\n        }\n\n        if (ex.code === 'CHARACTER_PARSER:END_OF_STRING_REACHED') {\n          this.error('NO_END_BRACKET', 'End of line was reached with no closing bracket for interpolation.');\n        } else if (ex.code === 'CHARACTER_PARSER:MISMATCHED_BRACKET') {\n          this.error('BRACKET_MISMATCH', ex.message);\n        } else {\n          throw ex;\n        }\n      }\n\n      tok.mustEscape = matchOfStringInterp[2] === '#';\n      tok.buffer = true;\n      tok.val = range.src;\n      this.assertExpression(range.src);\n\n      if (range.end + 1 < rest.length) {\n        rest = rest.substr(range.end + 1);\n        this.incrementColumn(range.end + 1);\n        this.tokens.push(this.tokEnd(tok));\n        this.addText(type, rest);\n      } else {\n        this.incrementColumn(rest.length);\n        this.tokens.push(this.tokEnd(tok));\n      }\n\n      return;\n    }\n\n    value = prefix + value;\n    tok = this.tok(type, value);\n    this.incrementColumn(value.length + escaped);\n    this.tokens.push(this.tokEnd(tok));\n  },\n  text: function () {\n    var tok = this.scan(/^(?:\\| ?| )([^\\n]+)/, 'text') || this.scan(/^( )/, 'text') || this.scan(/^\\|( ?)/, 'text');\n\n    if (tok) {\n      this.addText('text', tok.val);\n      return true;\n    }\n  },\n  textHtml: function () {\n    var tok = this.scan(/^(<[^\\n]*)/, 'text-html');\n\n    if (tok) {\n      this.addText('text-html', tok.val);\n      return true;\n    }\n  },\n\n  /**\n   * Dot.\n   */\n  dot: function () {\n    var tok;\n\n    if (tok = this.scanEndOfLine(/^\\./, 'dot')) {\n      this.tokens.push(this.tokEnd(tok));\n      this.callLexerFunction('pipelessText');\n      return true;\n    }\n  },\n\n  /**\n   * Extends.\n   */\n  extends: function () {\n    var tok = this.scan(/^extends?(?= |$|\\n)/, 'extends');\n\n    if (tok) {\n      this.tokens.push(this.tokEnd(tok));\n\n      if (!this.callLexerFunction('path')) {\n        this.error('NO_EXTENDS_PATH', 'missing path for extends');\n      }\n\n      return true;\n    }\n\n    if (this.scan(/^extends?\\b/)) {\n      this.error('MALFORMED_EXTENDS', 'malformed extends');\n    }\n  },\n\n  /**\n   * Block prepend.\n   */\n  prepend: function () {\n    var captures;\n\n    if (captures = /^(?:block +)?prepend +([^\\n]+)/.exec(this.input)) {\n      var name = captures[1].trim();\n      var comment = '';\n\n      if (name.indexOf('//') !== -1) {\n        comment = '//' + name.split('//').slice(1).join('//');\n        name = name.split('//')[0].trim();\n      }\n\n      if (!name) return;\n      var tok = this.tok('block', name);\n      var len = captures[0].length - comment.length;\n\n      while (this.whitespaceRe.test(this.input.charAt(len - 1))) len--;\n\n      this.incrementColumn(len);\n      tok.mode = 'prepend';\n      this.tokens.push(this.tokEnd(tok));\n      this.consume(captures[0].length - comment.length);\n      this.incrementColumn(captures[0].length - comment.length - len);\n      return true;\n    }\n  },\n\n  /**\n   * Block append.\n   */\n  append: function () {\n    var captures;\n\n    if (captures = /^(?:block +)?append +([^\\n]+)/.exec(this.input)) {\n      var name = captures[1].trim();\n      var comment = '';\n\n      if (name.indexOf('//') !== -1) {\n        comment = '//' + name.split('//').slice(1).join('//');\n        name = name.split('//')[0].trim();\n      }\n\n      if (!name) return;\n      var tok = this.tok('block', name);\n      var len = captures[0].length - comment.length;\n\n      while (this.whitespaceRe.test(this.input.charAt(len - 1))) len--;\n\n      this.incrementColumn(len);\n      tok.mode = 'append';\n      this.tokens.push(this.tokEnd(tok));\n      this.consume(captures[0].length - comment.length);\n      this.incrementColumn(captures[0].length - comment.length - len);\n      return true;\n    }\n  },\n\n  /**\n   * Block.\n   */\n  block: function () {\n    var captures;\n\n    if (captures = /^block +([^\\n]+)/.exec(this.input)) {\n      var name = captures[1].trim();\n      var comment = '';\n\n      if (name.indexOf('//') !== -1) {\n        comment = '//' + name.split('//').slice(1).join('//');\n        name = name.split('//')[0].trim();\n      }\n\n      if (!name) return;\n      var tok = this.tok('block', name);\n      var len = captures[0].length - comment.length;\n\n      while (this.whitespaceRe.test(this.input.charAt(len - 1))) len--;\n\n      this.incrementColumn(len);\n      tok.mode = 'replace';\n      this.tokens.push(this.tokEnd(tok));\n      this.consume(captures[0].length - comment.length);\n      this.incrementColumn(captures[0].length - comment.length - len);\n      return true;\n    }\n  },\n\n  /**\n   * Mixin Block.\n   */\n  mixinBlock: function () {\n    var tok;\n\n    if (tok = this.scanEndOfLine(/^block/, 'mixin-block')) {\n      this.tokens.push(this.tokEnd(tok));\n      return true;\n    }\n  },\n\n  /**\n   * Yield.\n   */\n  yield: function () {\n    var tok = this.scanEndOfLine(/^yield/, 'yield');\n\n    if (tok) {\n      this.tokens.push(this.tokEnd(tok));\n      return true;\n    }\n  },\n\n  /**\n   * Include.\n   */\n  include: function () {\n    var tok = this.scan(/^include(?=:| |$|\\n)/, 'include');\n\n    if (tok) {\n      this.tokens.push(this.tokEnd(tok));\n\n      while (this.callLexerFunction('filter', {\n        inInclude: true\n      }));\n\n      if (!this.callLexerFunction('path')) {\n        if (/^[^ \\n]+/.test(this.input)) {\n          // if there is more text\n          this.fail();\n        } else {\n          // if not\n          this.error('NO_INCLUDE_PATH', 'missing path for include');\n        }\n      }\n\n      return true;\n    }\n\n    if (this.scan(/^include\\b/)) {\n      this.error('MALFORMED_INCLUDE', 'malformed include');\n    }\n  },\n\n  /**\n   * Path\n   */\n  path: function () {\n    var tok = this.scanEndOfLine(/^ ([^\\n]+)/, 'path');\n\n    if (tok && (tok.val = tok.val.trim())) {\n      this.tokens.push(this.tokEnd(tok));\n      return true;\n    }\n  },\n\n  /**\n   * Case.\n   */\n  case: function () {\n    var tok = this.scanEndOfLine(/^case +([^\\n]+)/, 'case');\n\n    if (tok) {\n      this.incrementColumn(-tok.val.length);\n      this.assertExpression(tok.val);\n      this.incrementColumn(tok.val.length);\n      this.tokens.push(this.tokEnd(tok));\n      return true;\n    }\n\n    if (this.scan(/^case\\b/)) {\n      this.error('NO_CASE_EXPRESSION', 'missing expression for case');\n    }\n  },\n\n  /**\n   * When.\n   */\n  when: function () {\n    var tok = this.scanEndOfLine(/^when +([^:\\n]+)/, 'when');\n\n    if (tok) {\n      var parser = characterParser(tok.val);\n\n      while (parser.isNesting() || parser.isString()) {\n        var rest = /:([^:\\n]+)/.exec(this.input);\n        if (!rest) break;\n        tok.val += rest[0];\n        this.consume(rest[0].length);\n        this.incrementColumn(rest[0].length);\n        parser = characterParser(tok.val);\n      }\n\n      this.incrementColumn(-tok.val.length);\n      this.assertExpression(tok.val);\n      this.incrementColumn(tok.val.length);\n      this.tokens.push(this.tokEnd(tok));\n      return true;\n    }\n\n    if (this.scan(/^when\\b/)) {\n      this.error('NO_WHEN_EXPRESSION', 'missing expression for when');\n    }\n  },\n\n  /**\n   * Default.\n   */\n  default: function () {\n    var tok = this.scanEndOfLine(/^default/, 'default');\n\n    if (tok) {\n      this.tokens.push(this.tokEnd(tok));\n      return true;\n    }\n\n    if (this.scan(/^default\\b/)) {\n      this.error('DEFAULT_WITH_EXPRESSION', 'default should not have an expression');\n    }\n  },\n\n  /**\n   * Call mixin.\n   */\n  call: function () {\n    var tok, captures, increment;\n\n    if (captures = /^\\+(\\s*)(([-\\w]+)|(#\\{))/.exec(this.input)) {\n      // try to consume simple or interpolated call\n      if (captures[3]) {\n        // simple call\n        increment = captures[0].length;\n        this.consume(increment);\n        tok = this.tok('call', captures[3]);\n      } else {\n        // interpolated call\n        var match = this.bracketExpression(2 + captures[1].length);\n        increment = match.end + 1;\n        this.consume(increment);\n        this.assertExpression(match.src);\n        tok = this.tok('call', '#{' + match.src + '}');\n      }\n\n      this.incrementColumn(increment);\n      tok.args = null; // Check for args (not attributes)\n\n      if (captures = /^ *\\(/.exec(this.input)) {\n        var range = this.bracketExpression(captures[0].length - 1);\n\n        if (!/^\\s*[-\\w]+ *=/.test(range.src)) {\n          // not attributes\n          this.incrementColumn(1);\n          this.consume(range.end + 1);\n          tok.args = range.src;\n          this.assertExpression('[' + tok.args + ']');\n\n          for (var i = 0; i <= tok.args.length; i++) {\n            if (tok.args[i] === '\\n') {\n              this.incrementLine(1);\n            } else {\n              this.incrementColumn(1);\n            }\n          }\n        }\n      }\n\n      this.tokens.push(this.tokEnd(tok));\n      return true;\n    }\n  },\n\n  /**\n   * Mixin.\n   */\n  mixin: function () {\n    var captures;\n\n    if (captures = /^mixin +([-\\w]+)(?: *\\((.*)\\))? */.exec(this.input)) {\n      this.consume(captures[0].length);\n      var tok = this.tok('mixin', captures[1]);\n      tok.args = captures[2] || null;\n      this.incrementColumn(captures[0].length);\n      this.tokens.push(this.tokEnd(tok));\n      return true;\n    }\n  },\n\n  /**\n   * Conditional.\n   */\n  conditional: function () {\n    var captures;\n\n    if (captures = /^(if|unless|else if|else)\\b([^\\n]*)/.exec(this.input)) {\n      this.consume(captures[0].length);\n      var type = captures[1].replace(/ /g, '-');\n      var js = captures[2] && captures[2].trim(); // type can be \"if\", \"else-if\" and \"else\"\n\n      var tok = this.tok(type, js);\n      this.incrementColumn(captures[0].length - js.length);\n\n      switch (type) {\n        case 'if':\n        case 'else-if':\n          this.assertExpression(js);\n          break;\n\n        case 'unless':\n          this.assertExpression(js);\n          tok.val = '!(' + js + ')';\n          tok.type = 'if';\n          break;\n\n        case 'else':\n          if (js) {\n            this.error('ELSE_CONDITION', '`else` cannot have a condition, perhaps you meant `else if`');\n          }\n\n          break;\n      }\n\n      this.incrementColumn(js.length);\n      this.tokens.push(this.tokEnd(tok));\n      return true;\n    }\n  },\n\n  /**\n   * While.\n   */\n  while: function () {\n    var captures, tok;\n\n    if (captures = /^while +([^\\n]+)/.exec(this.input)) {\n      this.consume(captures[0].length);\n      this.assertExpression(captures[1]);\n      tok = this.tok('while', captures[1]);\n      this.incrementColumn(captures[0].length);\n      this.tokens.push(this.tokEnd(tok));\n      return true;\n    }\n\n    if (this.scan(/^while\\b/)) {\n      this.error('NO_WHILE_EXPRESSION', 'missing expression for while');\n    }\n  },\n\n  /**\n   * Each.\n   */\n  each: function () {\n    var captures;\n\n    if (captures = /^(?:each|for) +([a-zA-Z_$][\\w$]*)(?: *, *([a-zA-Z_$][\\w$]*))? * in *([^\\n]+)/.exec(this.input)) {\n      this.consume(captures[0].length);\n      var tok = this.tok('each', captures[1]);\n      tok.key = captures[2] || null;\n      this.incrementColumn(captures[0].length - captures[3].length);\n      this.assertExpression(captures[3]);\n      tok.code = captures[3];\n      this.incrementColumn(captures[3].length);\n      this.tokens.push(this.tokEnd(tok));\n      return true;\n    }\n\n    const name = /^each\\b/.exec(this.input) ? 'each' : 'for';\n\n    if (this.scan(/^(?:each|for)\\b/)) {\n      this.error('MALFORMED_EACH', 'This `' + name + '` has a syntax error. `' + name + '` statements should be of the form: `' + name + ' VARIABLE_NAME of JS_EXPRESSION`');\n    }\n\n    if (captures = /^- *(?:each|for) +([a-zA-Z_$][\\w$]*)(?: *, *([a-zA-Z_$][\\w$]*))? +in +([^\\n]+)/.exec(this.input)) {\n      this.error('MALFORMED_EACH', 'Pug each and for should no longer be prefixed with a dash (\"-\"). They are pug keywords and not part of JavaScript.');\n    }\n  },\n\n  /**\n   * EachOf.\n   */\n  eachOf: function () {\n    var captures;\n\n    if (captures = /^(?:each|for) (.*) of *([^\\n]+)/.exec(this.input)) {\n      this.consume(captures[0].length);\n      var tok = this.tok('eachOf', captures[1]);\n      tok.value = captures[1];\n      this.incrementColumn(captures[0].length - captures[2].length);\n      this.assertExpression(captures[2]);\n      tok.code = captures[2];\n      this.incrementColumn(captures[2].length);\n      this.tokens.push(this.tokEnd(tok));\n\n      if (!(/^[a-zA-Z_$][\\w$]*$/.test(tok.value.trim()) || /^\\[ *[a-zA-Z_$][\\w$]* *\\, *[a-zA-Z_$][\\w$]* *\\]$/.test(tok.value.trim()))) {\n        this.error('MALFORMED_EACH_OF_LVAL', 'The value variable for each must either be a valid identifier (e.g. `item`) or a pair of identifiers in square brackets (e.g. `[key, value]`).');\n      }\n\n      return true;\n    }\n\n    if (captures = /^- *(?:each|for) +([a-zA-Z_$][\\w$]*)(?: *, *([a-zA-Z_$][\\w$]*))? +of +([^\\n]+)/.exec(this.input)) {\n      this.error('MALFORMED_EACH', 'Pug each and for should not be prefixed with a dash (\"-\"). They are pug keywords and not part of JavaScript.');\n    }\n  },\n\n  /**\n   * Code.\n   */\n  code: function () {\n    var captures;\n\n    if (captures = /^(!?=|-)[ \\t]*([^\\n]+)/.exec(this.input)) {\n      var flags = captures[1];\n      var code = captures[2];\n      var shortened = 0;\n\n      if (this.interpolated) {\n        var parsed;\n\n        try {\n          parsed = characterParser.parseUntil(code, ']');\n        } catch (err) {\n          if (err.index !== undefined) {\n            this.incrementColumn(captures[0].length - code.length + err.index);\n          }\n\n          if (err.code === 'CHARACTER_PARSER:END_OF_STRING_REACHED') {\n            this.error('NO_END_BRACKET', 'End of line was reached with no closing bracket for interpolation.');\n          } else if (err.code === 'CHARACTER_PARSER:MISMATCHED_BRACKET') {\n            this.error('BRACKET_MISMATCH', err.message);\n          } else {\n            throw err;\n          }\n        }\n\n        shortened = code.length - parsed.end;\n        code = parsed.src;\n      }\n\n      var consumed = captures[0].length - shortened;\n      this.consume(consumed);\n      var tok = this.tok('code', code);\n      tok.mustEscape = flags.charAt(0) === '=';\n      tok.buffer = flags.charAt(0) === '=' || flags.charAt(1) === '='; // p #[!=    abc] hey\n      //     ^              original colno\n      //     -------------- captures[0]\n      //           -------- captures[2]\n      //     ------         captures[0] - captures[2]\n      //           ^        after colno\n      // =   abc\n      // ^                  original colno\n      // -------            captures[0]\n      //     ---            captures[2]\n      // ----               captures[0] - captures[2]\n      //     ^              after colno\n\n      this.incrementColumn(captures[0].length - captures[2].length);\n      if (tok.buffer) this.assertExpression(code);\n      this.tokens.push(tok); // p #[!=    abc] hey\n      //           ^        original colno\n      //              ----- shortened\n      //           ---      code\n      //              ^     after colno\n      // =   abc\n      //     ^              original colno\n      //                    shortened\n      //     ---            code\n      //        ^           after colno\n\n      this.incrementColumn(code.length);\n      this.tokEnd(tok);\n      return true;\n    }\n  },\n\n  /**\n   * Block code.\n   */\n  blockCode: function () {\n    var tok;\n\n    if (tok = this.scanEndOfLine(/^-/, 'blockcode')) {\n      this.tokens.push(this.tokEnd(tok));\n      this.interpolationAllowed = false;\n      this.callLexerFunction('pipelessText');\n      return true;\n    }\n  },\n\n  /**\n   * Attribute Name.\n   */\n  attribute: function (str) {\n    var quote = '';\n    var quoteRe = /['\"]/;\n    var key = '';\n    var i; // consume all whitespace before the key\n\n    for (i = 0; i < str.length; i++) {\n      if (!this.whitespaceRe.test(str[i])) break;\n\n      if (str[i] === '\\n') {\n        this.incrementLine(1);\n      } else {\n        this.incrementColumn(1);\n      }\n    }\n\n    if (i === str.length) {\n      return '';\n    }\n\n    var tok = this.tok('attribute'); // quote?\n\n    if (quoteRe.test(str[i])) {\n      quote = str[i];\n      this.incrementColumn(1);\n      i++;\n    } // start looping through the key\n\n\n    for (; i < str.length; i++) {\n      if (quote) {\n        if (str[i] === quote) {\n          this.incrementColumn(1);\n          i++;\n          break;\n        }\n      } else {\n        if (this.whitespaceRe.test(str[i]) || str[i] === '!' || str[i] === '=' || str[i] === ',') {\n          break;\n        }\n      }\n\n      key += str[i];\n\n      if (str[i] === '\\n') {\n        this.incrementLine(1);\n      } else {\n        this.incrementColumn(1);\n      }\n    }\n\n    tok.name = key;\n    var valueResponse = this.attributeValue(str.substr(i));\n\n    if (valueResponse.val) {\n      tok.val = valueResponse.val;\n      tok.mustEscape = valueResponse.mustEscape;\n    } else {\n      // was a boolean attribute (ex: `input(disabled)`)\n      tok.val = true;\n      tok.mustEscape = true;\n    }\n\n    str = valueResponse.remainingSource;\n    this.tokens.push(this.tokEnd(tok));\n\n    for (i = 0; i < str.length; i++) {\n      if (!this.whitespaceRe.test(str[i])) {\n        break;\n      }\n\n      if (str[i] === '\\n') {\n        this.incrementLine(1);\n      } else {\n        this.incrementColumn(1);\n      }\n    }\n\n    if (str[i] === ',') {\n      this.incrementColumn(1);\n      i++;\n    }\n\n    return str.substr(i);\n  },\n\n  /**\n   * Attribute Value.\n   */\n  attributeValue: function (str) {\n    var quoteRe = /['\"]/;\n    var val = '';\n    var done, i, x;\n    var escapeAttr = true;\n    var state = characterParser.defaultState();\n    var col = this.colno;\n    var line = this.lineno; // consume all whitespace before the equals sign\n\n    for (i = 0; i < str.length; i++) {\n      if (!this.whitespaceRe.test(str[i])) break;\n\n      if (str[i] === '\\n') {\n        line++;\n        col = 1;\n      } else {\n        col++;\n      }\n    }\n\n    if (i === str.length) {\n      return {\n        remainingSource: str\n      };\n    }\n\n    if (str[i] === '!') {\n      escapeAttr = false;\n      col++;\n      i++;\n      if (str[i] !== '=') this.error('INVALID_KEY_CHARACTER', 'Unexpected character ' + str[i] + ' expected `=`');\n    }\n\n    if (str[i] !== '=') {\n      // check for anti-pattern `div(\"foo\"bar)`\n      if (i === 0 && str && !this.whitespaceRe.test(str[0]) && str[0] !== ',') {\n        this.error('INVALID_KEY_CHARACTER', 'Unexpected character ' + str[0] + ' expected `=`');\n      } else {\n        return {\n          remainingSource: str\n        };\n      }\n    }\n\n    this.lineno = line;\n    this.colno = col + 1;\n    i++; // consume all whitespace before the value\n\n    for (; i < str.length; i++) {\n      if (!this.whitespaceRe.test(str[i])) break;\n\n      if (str[i] === '\\n') {\n        this.incrementLine(1);\n      } else {\n        this.incrementColumn(1);\n      }\n    }\n\n    line = this.lineno;\n    col = this.colno; // start looping through the value\n\n    for (; i < str.length; i++) {\n      // if the character is in a string or in parentheses/brackets/braces\n      if (!(state.isNesting() || state.isString())) {\n        if (this.whitespaceRe.test(str[i])) {\n          done = false; // find the first non-whitespace character\n\n          for (x = i; x < str.length; x++) {\n            if (!this.whitespaceRe.test(str[x])) {\n              // if it is a JavaScript punctuator, then assume that it is\n              // a part of the value\n              const isNotPunctuator = !characterParser.isPunctuator(str[x]);\n              const isQuote = quoteRe.test(str[x]);\n              const isColon = str[x] === ':';\n              const isSpreadOperator = str[x] + str[x + 1] + str[x + 2] === '...';\n\n              if ((isNotPunctuator || isQuote || isColon || isSpreadOperator) && this.assertExpression(val, true)) {\n                done = true;\n              }\n\n              break;\n            }\n          } // if everything else is whitespace, return now so last attribute\n          // does not include trailing whitespace\n\n\n          if (done || x === str.length) {\n            break;\n          }\n        } // if there's no whitespace and the character is not ',', the\n        // attribute did not end.\n\n\n        if (str[i] === ',' && this.assertExpression(val, true)) {\n          break;\n        }\n      }\n\n      state = characterParser.parseChar(str[i], state);\n      val += str[i];\n\n      if (str[i] === '\\n') {\n        line++;\n        col = 1;\n      } else {\n        col++;\n      }\n    }\n\n    this.assertExpression(val);\n    this.lineno = line;\n    this.colno = col;\n    return {\n      val: val,\n      mustEscape: escapeAttr,\n      remainingSource: str.substr(i)\n    };\n  },\n\n  /**\n   * Attributes.\n   */\n  attrs: function () {\n    var tok;\n\n    if ('(' == this.input.charAt(0)) {\n      tok = this.tok('start-attributes');\n      var index = this.bracketExpression().end;\n      var str = this.input.substr(1, index - 1);\n      this.incrementColumn(1);\n      this.tokens.push(this.tokEnd(tok));\n      this.assertNestingCorrect(str);\n      this.consume(index + 1);\n\n      while (str) {\n        str = this.attribute(str);\n      }\n\n      tok = this.tok('end-attributes');\n      this.incrementColumn(1);\n      this.tokens.push(this.tokEnd(tok));\n      return true;\n    }\n  },\n\n  /**\n   * &attributes block\n   */\n  attributesBlock: function () {\n    if (/^&attributes\\b/.test(this.input)) {\n      var consumed = 11;\n      this.consume(consumed);\n      var tok = this.tok('&attributes');\n      this.incrementColumn(consumed);\n      var args = this.bracketExpression();\n      consumed = args.end + 1;\n      this.consume(consumed);\n      tok.val = args.src;\n      this.incrementColumn(consumed);\n      this.tokens.push(this.tokEnd(tok));\n      return true;\n    }\n  },\n\n  /**\n   * Indent | Outdent | Newline.\n   */\n  indent: function () {\n    var captures = this.scanIndentation();\n    var tok;\n\n    if (captures) {\n      var indents = captures[1].length;\n      this.incrementLine(1);\n      this.consume(indents + 1);\n\n      if (' ' == this.input[0] || '\\t' == this.input[0]) {\n        this.error('INVALID_INDENTATION', 'Invalid indentation, you can use tabs or spaces but not both');\n      } // blank line\n\n\n      if ('\\n' == this.input[0]) {\n        this.interpolationAllowed = true;\n        return this.tokEnd(this.tok('newline'));\n      } // outdent\n\n\n      if (indents < this.indentStack[0]) {\n        var outdent_count = 0;\n\n        while (this.indentStack[0] > indents) {\n          if (this.indentStack[1] < indents) {\n            this.error('INCONSISTENT_INDENTATION', 'Inconsistent indentation. Expecting either ' + this.indentStack[1] + ' or ' + this.indentStack[0] + ' spaces/tabs.');\n          }\n\n          outdent_count++;\n          this.indentStack.shift();\n        }\n\n        while (outdent_count--) {\n          this.colno = 1;\n          tok = this.tok('outdent');\n          this.colno = this.indentStack[0] + 1;\n          this.tokens.push(this.tokEnd(tok));\n        } // indent\n\n      } else if (indents && indents != this.indentStack[0]) {\n        tok = this.tok('indent', indents);\n        this.colno = 1 + indents;\n        this.tokens.push(this.tokEnd(tok));\n        this.indentStack.unshift(indents); // newline\n      } else {\n        tok = this.tok('newline');\n        this.colno = 1 + Math.min(this.indentStack[0] || 0, indents);\n        this.tokens.push(this.tokEnd(tok));\n      }\n\n      this.interpolationAllowed = true;\n      return true;\n    }\n  },\n  pipelessText: function pipelessText(indents) {\n    while (this.callLexerFunction('blank'));\n\n    var captures = this.scanIndentation();\n    indents = indents || captures && captures[1].length;\n\n    if (indents > this.indentStack[0]) {\n      this.tokens.push(this.tokEnd(this.tok('start-pipeless-text')));\n      var tokens = [];\n      var token_indent = [];\n      var isMatch; // Index in this.input. Can't use this.consume because we might need to\n      // retry lexing the block.\n\n      var stringPtr = 0;\n\n      do {\n        // text has `\\n` as a prefix\n        var i = this.input.substr(stringPtr + 1).indexOf('\\n');\n        if (-1 == i) i = this.input.length - stringPtr - 1;\n        var str = this.input.substr(stringPtr + 1, i);\n        var lineCaptures = this.indentRe.exec('\\n' + str);\n        var lineIndents = lineCaptures && lineCaptures[1].length;\n        isMatch = lineIndents >= indents;\n        token_indent.push(isMatch);\n        isMatch = isMatch || !str.trim();\n\n        if (isMatch) {\n          // consume test along with `\\n` prefix if match\n          stringPtr += str.length + 1;\n          tokens.push(str.substr(indents));\n        } else if (lineIndents > this.indentStack[0]) {\n          // line is indented less than the first line but is still indented\n          // need to retry lexing the text block\n          this.tokens.pop();\n          return pipelessText.call(this, lineCaptures[1].length);\n        }\n      } while (this.input.length - stringPtr && isMatch);\n\n      this.consume(stringPtr);\n\n      while (this.input.length === 0 && tokens[tokens.length - 1] === '') tokens.pop();\n\n      tokens.forEach(function (token, i) {\n        var tok;\n        this.incrementLine(1);\n        if (i !== 0) tok = this.tok('newline');\n        if (token_indent[i]) this.incrementColumn(indents);\n        if (tok) this.tokens.push(this.tokEnd(tok));\n        this.addText('text', token);\n      }.bind(this));\n      this.tokens.push(this.tokEnd(this.tok('end-pipeless-text')));\n      return true;\n    }\n  },\n\n  /**\n   * Slash.\n   */\n  slash: function () {\n    var tok = this.scan(/^\\//, 'slash');\n\n    if (tok) {\n      this.tokens.push(this.tokEnd(tok));\n      return true;\n    }\n  },\n\n  /**\n   * ':'\n   */\n  colon: function () {\n    var tok = this.scan(/^: +/, ':');\n\n    if (tok) {\n      this.tokens.push(this.tokEnd(tok));\n      return true;\n    }\n  },\n  fail: function () {\n    this.error('UNEXPECTED_TEXT', 'unexpected text \"' + this.input.substr(0, 5) + '\"');\n  },\n  callLexerFunction: function (func) {\n    var rest = [];\n\n    for (var i = 1; i < arguments.length; i++) {\n      rest.push(arguments[i]);\n    }\n\n    var pluginArgs = [this].concat(rest);\n\n    for (var i = 0; i < this.plugins.length; i++) {\n      var plugin = this.plugins[i];\n\n      if (plugin[func] && plugin[func].apply(plugin, pluginArgs)) {\n        return true;\n      }\n    }\n\n    return this[func].apply(this, rest);\n  },\n\n  /**\n   * Move to the next token\n   *\n   * @api private\n   */\n  advance: function () {\n    return this.callLexerFunction('blank') || this.callLexerFunction('eos') || this.callLexerFunction('endInterpolation') || this.callLexerFunction('yield') || this.callLexerFunction('doctype') || this.callLexerFunction('interpolation') || this.callLexerFunction('case') || this.callLexerFunction('when') || this.callLexerFunction('default') || this.callLexerFunction('extends') || this.callLexerFunction('append') || this.callLexerFunction('prepend') || this.callLexerFunction('block') || this.callLexerFunction('mixinBlock') || this.callLexerFunction('include') || this.callLexerFunction('mixin') || this.callLexerFunction('call') || this.callLexerFunction('conditional') || this.callLexerFunction('eachOf') || this.callLexerFunction('each') || this.callLexerFunction('while') || this.callLexerFunction('tag') || this.callLexerFunction('filter') || this.callLexerFunction('blockCode') || this.callLexerFunction('code') || this.callLexerFunction('id') || this.callLexerFunction('dot') || this.callLexerFunction('className') || this.callLexerFunction('attrs') || this.callLexerFunction('attributesBlock') || this.callLexerFunction('indent') || this.callLexerFunction('text') || this.callLexerFunction('textHtml') || this.callLexerFunction('comment') || this.callLexerFunction('slash') || this.callLexerFunction('colon') || this.fail();\n  },\n\n  /**\n   * Return an array of tokens for the current file\n   *\n   * @returns {Array.<Token>}\n   * @api public\n   */\n  getTokens: function () {\n    while (!this.ended) {\n      this.callLexerFunction('advance');\n    }\n\n    return this.tokens;\n  }\n};","map":{"version":3,"sources":["C:/Users/bekke/Documents/Art Website/node_modules/pug-lexer/index.js"],"names":["assert","require","isExpression","characterParser","error","module","exports","lex","Lexer","str","options","lexer","JSON","parse","stringify","getTokens","Error","replace","input","originalInput","filename","interpolated","lineno","startingLine","colno","startingColumn","plugins","indentStack","indentRe","interpolationAllowed","whitespaceRe","tokens","ended","prototype","constructor","code","message","err","line","column","src","value","exp","throw","assertExpression","noThrow","callLexerFunction","ex","loc","incrementLine","incrementColumn","msg","assertNestingCorrect","res","isNesting","tok","type","val","start","undefined","tokEnd","end","increment","consume","len","substr","scan","regexp","captures","exec","length","diff","scanEndOfLine","whitespaceLength","whitespace","newInput","test","bracketExpression","skip","BRACKETS","range","parseUntil","index","idx","tmp","indexOf","nextNewline","ptr","scanIndentation","re","eos","i","push","blank","comment","buffer","interpolation","match","splitted","split","lines","tag","name","filter","opts","inInclude","doctype","node","id","className","endInterpolation","addText","prefix","escaped","indexOfEnd","indexOfStart","indexOfEscaped","matchOfStringInterp","indexOfStringInterp","Infinity","substring","child","concat","before","rest","mustEscape","text","textHtml","dot","extends","prepend","trim","slice","join","charAt","mode","append","block","mixinBlock","yield","include","fail","path","case","when","parser","isString","default","call","args","mixin","conditional","js","while","each","key","eachOf","flags","shortened","parsed","consumed","blockCode","attribute","quote","quoteRe","valueResponse","attributeValue","remainingSource","done","x","escapeAttr","state","defaultState","col","isNotPunctuator","isPunctuator","isQuote","isColon","isSpreadOperator","parseChar","attrs","attributesBlock","indent","indents","outdent_count","shift","unshift","Math","min","pipelessText","token_indent","isMatch","stringPtr","lineCaptures","lineIndents","pop","forEach","token","bind","slash","colon","func","arguments","pluginArgs","plugin","apply","advance"],"mappings":"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","sourcesContent":["'use strict';\n\nvar assert = require('assert');\nvar isExpression = require('is-expression');\nvar characterParser = require('character-parser');\nvar error = require('pug-error');\n\nmodule.exports = lex;\nmodule.exports.Lexer = Lexer;\nfunction lex(str, options) {\n  var lexer = new Lexer(str, options);\n  return JSON.parse(JSON.stringify(lexer.getTokens()));\n}\n\n/**\n * Initialize `Lexer` with the given `str`.\n *\n * @param {String} str\n * @param {String} filename\n * @api private\n */\n\nfunction Lexer(str, options) {\n  options = options || {};\n  if (typeof str !== 'string') {\n    throw new Error(\n      'Expected source code to be a string but got \"' + typeof str + '\"'\n    );\n  }\n  if (typeof options !== 'object') {\n    throw new Error(\n      'Expected \"options\" to be an object but got \"' + typeof options + '\"'\n    );\n  }\n  //Strip any UTF-8 BOM off of the start of `str`, if it exists.\n  str = str.replace(/^\\uFEFF/, '');\n  this.input = str.replace(/\\r\\n|\\r/g, '\\n');\n  this.originalInput = this.input;\n  this.filename = options.filename;\n  this.interpolated = options.interpolated || false;\n  this.lineno = options.startingLine || 1;\n  this.colno = options.startingColumn || 1;\n  this.plugins = options.plugins || [];\n  this.indentStack = [0];\n  this.indentRe = null;\n  // If #{}, !{} or #[] syntax is allowed when adding text\n  this.interpolationAllowed = true;\n  this.whitespaceRe = /[ \\n\\t]/;\n\n  this.tokens = [];\n  this.ended = false;\n}\n\n/**\n * Lexer prototype.\n */\n\nLexer.prototype = {\n  constructor: Lexer,\n\n  error: function(code, message) {\n    var err = error(code, message, {\n      line: this.lineno,\n      column: this.colno,\n      filename: this.filename,\n      src: this.originalInput,\n    });\n    throw err;\n  },\n\n  assert: function(value, message) {\n    if (!value) this.error('ASSERT_FAILED', message);\n  },\n\n  isExpression: function(exp) {\n    return isExpression(exp, {\n      throw: true,\n    });\n  },\n\n  assertExpression: function(exp, noThrow) {\n    //this verifies that a JavaScript expression is valid\n    try {\n      this.callLexerFunction('isExpression', exp);\n      return true;\n    } catch (ex) {\n      if (noThrow) return false;\n\n      // not coming from acorn\n      if (!ex.loc) throw ex;\n\n      this.incrementLine(ex.loc.line - 1);\n      this.incrementColumn(ex.loc.column);\n      var msg =\n        'Syntax Error: ' + ex.message.replace(/ \\([0-9]+:[0-9]+\\)$/, '');\n      this.error('SYNTAX_ERROR', msg);\n    }\n  },\n\n  assertNestingCorrect: function(exp) {\n    //this verifies that code is properly nested, but allows\n    //invalid JavaScript such as the contents of `attributes`\n    var res = characterParser(exp);\n    if (res.isNesting()) {\n      this.error(\n        'INCORRECT_NESTING',\n        'Nesting must match on expression `' + exp + '`'\n      );\n    }\n  },\n\n  /**\n   * Construct a token with the given `type` and `val`.\n   *\n   * @param {String} type\n   * @param {String} val\n   * @return {Object}\n   * @api private\n   */\n\n  tok: function(type, val) {\n    var res = {\n      type: type,\n      loc: {\n        start: {\n          line: this.lineno,\n          column: this.colno,\n        },\n        filename: this.filename,\n      },\n    };\n\n    if (val !== undefined) res.val = val;\n\n    return res;\n  },\n\n  /**\n   * Set the token's `loc.end` value.\n   *\n   * @param {Object} tok\n   * @returns {Object}\n   * @api private\n   */\n\n  tokEnd: function(tok) {\n    tok.loc.end = {\n      line: this.lineno,\n      column: this.colno,\n    };\n    return tok;\n  },\n\n  /**\n   * Increment `this.lineno` and reset `this.colno`.\n   *\n   * @param {Number} increment\n   * @api private\n   */\n\n  incrementLine: function(increment) {\n    this.lineno += increment;\n    if (increment) this.colno = 1;\n  },\n\n  /**\n   * Increment `this.colno`.\n   *\n   * @param {Number} increment\n   * @api private\n   */\n\n  incrementColumn: function(increment) {\n    this.colno += increment;\n  },\n\n  /**\n   * Consume the given `len` of input.\n   *\n   * @param {Number} len\n   * @api private\n   */\n\n  consume: function(len) {\n    this.input = this.input.substr(len);\n  },\n\n  /**\n   * Scan for `type` with the given `regexp`.\n   *\n   * @param {String} type\n   * @param {RegExp} regexp\n   * @return {Object}\n   * @api private\n   */\n\n  scan: function(regexp, type) {\n    var captures;\n    if ((captures = regexp.exec(this.input))) {\n      var len = captures[0].length;\n      var val = captures[1];\n      var diff = len - (val ? val.length : 0);\n      var tok = this.tok(type, val);\n      this.consume(len);\n      this.incrementColumn(diff);\n      return tok;\n    }\n  },\n  scanEndOfLine: function(regexp, type) {\n    var captures;\n    if ((captures = regexp.exec(this.input))) {\n      var whitespaceLength = 0;\n      var whitespace;\n      var tok;\n      if ((whitespace = /^([ ]+)([^ ]*)/.exec(captures[0]))) {\n        whitespaceLength = whitespace[1].length;\n        this.incrementColumn(whitespaceLength);\n      }\n      var newInput = this.input.substr(captures[0].length);\n      if (newInput[0] === ':') {\n        this.input = newInput;\n        tok = this.tok(type, captures[1]);\n        this.incrementColumn(captures[0].length - whitespaceLength);\n        return tok;\n      }\n      if (/^[ \\t]*(\\n|$)/.test(newInput)) {\n        this.input = newInput.substr(/^[ \\t]*/.exec(newInput)[0].length);\n        tok = this.tok(type, captures[1]);\n        this.incrementColumn(captures[0].length - whitespaceLength);\n        return tok;\n      }\n    }\n  },\n\n  /**\n   * Return the indexOf `(` or `{` or `[` / `)` or `}` or `]` delimiters.\n   *\n   * Make sure that when calling this function, colno is at the character\n   * immediately before the beginning.\n   *\n   * @return {Number}\n   * @api private\n   */\n\n  bracketExpression: function(skip) {\n    skip = skip || 0;\n    var start = this.input[skip];\n    assert(\n      start === '(' || start === '{' || start === '[',\n      'The start character should be \"(\", \"{\" or \"[\"'\n    );\n    var end = characterParser.BRACKETS[start];\n    var range;\n    try {\n      range = characterParser.parseUntil(this.input, end, {start: skip + 1});\n    } catch (ex) {\n      if (ex.index !== undefined) {\n        var idx = ex.index;\n        // starting from this.input[skip]\n        var tmp = this.input.substr(skip).indexOf('\\n');\n        // starting from this.input[0]\n        var nextNewline = tmp + skip;\n        var ptr = 0;\n        while (idx > nextNewline && tmp !== -1) {\n          this.incrementLine(1);\n          idx -= nextNewline + 1;\n          ptr += nextNewline + 1;\n          tmp = nextNewline = this.input.substr(ptr).indexOf('\\n');\n        }\n\n        this.incrementColumn(idx);\n      }\n      if (ex.code === 'CHARACTER_PARSER:END_OF_STRING_REACHED') {\n        this.error(\n          'NO_END_BRACKET',\n          'The end of the string reached with no closing bracket ' +\n            end +\n            ' found.'\n        );\n      } else if (ex.code === 'CHARACTER_PARSER:MISMATCHED_BRACKET') {\n        this.error('BRACKET_MISMATCH', ex.message);\n      }\n      throw ex;\n    }\n    return range;\n  },\n\n  scanIndentation: function() {\n    var captures, re;\n\n    // established regexp\n    if (this.indentRe) {\n      captures = this.indentRe.exec(this.input);\n      // determine regexp\n    } else {\n      // tabs\n      re = /^\\n(\\t*) */;\n      captures = re.exec(this.input);\n\n      // spaces\n      if (captures && !captures[1].length) {\n        re = /^\\n( *)/;\n        captures = re.exec(this.input);\n      }\n\n      // established\n      if (captures && captures[1].length) this.indentRe = re;\n    }\n\n    return captures;\n  },\n\n  /**\n   * end-of-source.\n   */\n\n  eos: function() {\n    if (this.input.length) return;\n    if (this.interpolated) {\n      this.error(\n        'NO_END_BRACKET',\n        'End of line was reached with no closing bracket for interpolation.'\n      );\n    }\n    for (var i = 0; this.indentStack[i]; i++) {\n      this.tokens.push(this.tokEnd(this.tok('outdent')));\n    }\n    this.tokens.push(this.tokEnd(this.tok('eos')));\n    this.ended = true;\n    return true;\n  },\n\n  /**\n   * Blank line.\n   */\n\n  blank: function() {\n    var captures;\n    if ((captures = /^\\n[ \\t]*\\n/.exec(this.input))) {\n      this.consume(captures[0].length - 1);\n      this.incrementLine(1);\n      return true;\n    }\n  },\n\n  /**\n   * Comment.\n   */\n\n  comment: function() {\n    var captures;\n    if ((captures = /^\\/\\/(-)?([^\\n]*)/.exec(this.input))) {\n      this.consume(captures[0].length);\n      var tok = this.tok('comment', captures[2]);\n      tok.buffer = '-' != captures[1];\n      this.interpolationAllowed = tok.buffer;\n      this.tokens.push(tok);\n      this.incrementColumn(captures[0].length);\n      this.tokEnd(tok);\n      this.callLexerFunction('pipelessText');\n      return true;\n    }\n  },\n\n  /**\n   * Interpolated tag.\n   */\n\n  interpolation: function() {\n    if (/^#\\{/.test(this.input)) {\n      var match = this.bracketExpression(1);\n      this.consume(match.end + 1);\n      var tok = this.tok('interpolation', match.src);\n      this.tokens.push(tok);\n      this.incrementColumn(2); // '#{'\n      this.assertExpression(match.src);\n\n      var splitted = match.src.split('\\n');\n      var lines = splitted.length - 1;\n      this.incrementLine(lines);\n      this.incrementColumn(splitted[lines].length + 1); // + 1 â†’ '}'\n      this.tokEnd(tok);\n      return true;\n    }\n  },\n\n  /**\n   * Tag.\n   */\n\n  tag: function() {\n    var captures;\n\n    if ((captures = /^(\\w(?:[-:\\w]*\\w)?)/.exec(this.input))) {\n      var tok,\n        name = captures[1],\n        len = captures[0].length;\n      this.consume(len);\n      tok = this.tok('tag', name);\n      this.tokens.push(tok);\n      this.incrementColumn(len);\n      this.tokEnd(tok);\n      return true;\n    }\n  },\n\n  /**\n   * Filter.\n   */\n\n  filter: function(opts) {\n    var tok = this.scan(/^:([\\w\\-]+)/, 'filter');\n    var inInclude = opts && opts.inInclude;\n    if (tok) {\n      this.tokens.push(tok);\n      this.incrementColumn(tok.val.length);\n      this.tokEnd(tok);\n      this.callLexerFunction('attrs');\n      if (!inInclude) {\n        this.interpolationAllowed = false;\n        this.callLexerFunction('pipelessText');\n      }\n      return true;\n    }\n  },\n\n  /**\n   * Doctype.\n   */\n\n  doctype: function() {\n    var node = this.scanEndOfLine(/^doctype *([^\\n]*)/, 'doctype');\n    if (node) {\n      this.tokens.push(this.tokEnd(node));\n      return true;\n    }\n  },\n\n  /**\n   * Id.\n   */\n\n  id: function() {\n    var tok = this.scan(/^#([\\w-]+)/, 'id');\n    if (tok) {\n      this.tokens.push(tok);\n      this.incrementColumn(tok.val.length);\n      this.tokEnd(tok);\n      return true;\n    }\n    if (/^#/.test(this.input)) {\n      this.error(\n        'INVALID_ID',\n        '\"' +\n          /.[^ \\t\\(\\#\\.\\:]*/.exec(this.input.substr(1))[0] +\n          '\" is not a valid ID.'\n      );\n    }\n  },\n\n  /**\n   * Class.\n   */\n\n  className: function() {\n    var tok = this.scan(/^\\.([_a-z0-9\\-]*[_a-z][_a-z0-9\\-]*)/i, 'class');\n    if (tok) {\n      this.tokens.push(tok);\n      this.incrementColumn(tok.val.length);\n      this.tokEnd(tok);\n      return true;\n    }\n    if (/^\\.[_a-z0-9\\-]+/i.test(this.input)) {\n      this.error(\n        'INVALID_CLASS_NAME',\n        'Class names must contain at least one letter or underscore.'\n      );\n    }\n    if (/^\\./.test(this.input)) {\n      this.error(\n        'INVALID_CLASS_NAME',\n        '\"' +\n          /.[^ \\t\\(\\#\\.\\:]*/.exec(this.input.substr(1))[0] +\n          '\" is not a valid class name.  Class names can only contain \"_\", \"-\", a-z and 0-9, and must contain at least one of \"_\", or a-z'\n      );\n    }\n  },\n\n  /**\n   * Text.\n   */\n  endInterpolation: function() {\n    if (this.interpolated && this.input[0] === ']') {\n      this.input = this.input.substr(1);\n      this.ended = true;\n      return true;\n    }\n  },\n  addText: function(type, value, prefix, escaped) {\n    var tok;\n    if (value + prefix === '') return;\n    prefix = prefix || '';\n    escaped = escaped || 0;\n    var indexOfEnd = this.interpolated ? value.indexOf(']') : -1;\n    var indexOfStart = this.interpolationAllowed ? value.indexOf('#[') : -1;\n    var indexOfEscaped = this.interpolationAllowed ? value.indexOf('\\\\#[') : -1;\n    var matchOfStringInterp = /(\\\\)?([#!]){((?:.|\\n)*)$/.exec(value);\n    var indexOfStringInterp =\n      this.interpolationAllowed && matchOfStringInterp\n        ? matchOfStringInterp.index\n        : Infinity;\n\n    if (indexOfEnd === -1) indexOfEnd = Infinity;\n    if (indexOfStart === -1) indexOfStart = Infinity;\n    if (indexOfEscaped === -1) indexOfEscaped = Infinity;\n\n    if (\n      indexOfEscaped !== Infinity &&\n      indexOfEscaped < indexOfEnd &&\n      indexOfEscaped < indexOfStart &&\n      indexOfEscaped < indexOfStringInterp\n    ) {\n      prefix = prefix + value.substring(0, indexOfEscaped) + '#[';\n      return this.addText(\n        type,\n        value.substring(indexOfEscaped + 3),\n        prefix,\n        escaped + 1\n      );\n    }\n    if (\n      indexOfStart !== Infinity &&\n      indexOfStart < indexOfEnd &&\n      indexOfStart < indexOfEscaped &&\n      indexOfStart < indexOfStringInterp\n    ) {\n      tok = this.tok(type, prefix + value.substring(0, indexOfStart));\n      this.incrementColumn(prefix.length + indexOfStart + escaped);\n      this.tokens.push(this.tokEnd(tok));\n      tok = this.tok('start-pug-interpolation');\n      this.incrementColumn(2);\n      this.tokens.push(this.tokEnd(tok));\n      var child = new this.constructor(value.substr(indexOfStart + 2), {\n        filename: this.filename,\n        interpolated: true,\n        startingLine: this.lineno,\n        startingColumn: this.colno,\n      });\n      var interpolated;\n      try {\n        interpolated = child.getTokens();\n      } catch (ex) {\n        if (ex.code && /^PUG:/.test(ex.code)) {\n          this.colno = ex.column;\n          this.error(ex.code.substr(4), ex.msg);\n        }\n        throw ex;\n      }\n      this.colno = child.colno;\n      this.tokens = this.tokens.concat(interpolated);\n      tok = this.tok('end-pug-interpolation');\n      this.incrementColumn(1);\n      this.tokens.push(this.tokEnd(tok));\n      this.addText(type, child.input);\n      return;\n    }\n    if (\n      indexOfEnd !== Infinity &&\n      indexOfEnd < indexOfStart &&\n      indexOfEnd < indexOfEscaped &&\n      indexOfEnd < indexOfStringInterp\n    ) {\n      if (prefix + value.substring(0, indexOfEnd)) {\n        this.addText(type, value.substring(0, indexOfEnd), prefix);\n      }\n      this.ended = true;\n      this.input = value.substr(value.indexOf(']') + 1) + this.input;\n      return;\n    }\n    if (indexOfStringInterp !== Infinity) {\n      if (matchOfStringInterp[1]) {\n        prefix = prefix + value.substring(0, indexOfStringInterp) + '#{';\n        return this.addText(\n          type,\n          value.substring(indexOfStringInterp + 3),\n          prefix,\n          escaped + 1\n        );\n      }\n      var before = value.substr(0, indexOfStringInterp);\n      if (prefix || before) {\n        before = prefix + before;\n        tok = this.tok(type, before);\n        this.incrementColumn(before.length + escaped);\n        this.tokens.push(this.tokEnd(tok));\n      }\n\n      var rest = matchOfStringInterp[3];\n      var range;\n      tok = this.tok('interpolated-code');\n      this.incrementColumn(2);\n      try {\n        range = characterParser.parseUntil(rest, '}');\n      } catch (ex) {\n        if (ex.index !== undefined) {\n          this.incrementColumn(ex.index);\n        }\n        if (ex.code === 'CHARACTER_PARSER:END_OF_STRING_REACHED') {\n          this.error(\n            'NO_END_BRACKET',\n            'End of line was reached with no closing bracket for interpolation.'\n          );\n        } else if (ex.code === 'CHARACTER_PARSER:MISMATCHED_BRACKET') {\n          this.error('BRACKET_MISMATCH', ex.message);\n        } else {\n          throw ex;\n        }\n      }\n      tok.mustEscape = matchOfStringInterp[2] === '#';\n      tok.buffer = true;\n      tok.val = range.src;\n      this.assertExpression(range.src);\n\n      if (range.end + 1 < rest.length) {\n        rest = rest.substr(range.end + 1);\n        this.incrementColumn(range.end + 1);\n        this.tokens.push(this.tokEnd(tok));\n        this.addText(type, rest);\n      } else {\n        this.incrementColumn(rest.length);\n        this.tokens.push(this.tokEnd(tok));\n      }\n      return;\n    }\n\n    value = prefix + value;\n    tok = this.tok(type, value);\n    this.incrementColumn(value.length + escaped);\n    this.tokens.push(this.tokEnd(tok));\n  },\n\n  text: function() {\n    var tok =\n      this.scan(/^(?:\\| ?| )([^\\n]+)/, 'text') ||\n      this.scan(/^( )/, 'text') ||\n      this.scan(/^\\|( ?)/, 'text');\n    if (tok) {\n      this.addText('text', tok.val);\n      return true;\n    }\n  },\n\n  textHtml: function() {\n    var tok = this.scan(/^(<[^\\n]*)/, 'text-html');\n    if (tok) {\n      this.addText('text-html', tok.val);\n      return true;\n    }\n  },\n\n  /**\n   * Dot.\n   */\n\n  dot: function() {\n    var tok;\n    if ((tok = this.scanEndOfLine(/^\\./, 'dot'))) {\n      this.tokens.push(this.tokEnd(tok));\n      this.callLexerFunction('pipelessText');\n      return true;\n    }\n  },\n\n  /**\n   * Extends.\n   */\n\n  extends: function() {\n    var tok = this.scan(/^extends?(?= |$|\\n)/, 'extends');\n    if (tok) {\n      this.tokens.push(this.tokEnd(tok));\n      if (!this.callLexerFunction('path')) {\n        this.error('NO_EXTENDS_PATH', 'missing path for extends');\n      }\n      return true;\n    }\n    if (this.scan(/^extends?\\b/)) {\n      this.error('MALFORMED_EXTENDS', 'malformed extends');\n    }\n  },\n\n  /**\n   * Block prepend.\n   */\n\n  prepend: function() {\n    var captures;\n    if ((captures = /^(?:block +)?prepend +([^\\n]+)/.exec(this.input))) {\n      var name = captures[1].trim();\n      var comment = '';\n      if (name.indexOf('//') !== -1) {\n        comment =\n          '//' +\n          name\n            .split('//')\n            .slice(1)\n            .join('//');\n        name = name.split('//')[0].trim();\n      }\n      if (!name) return;\n      var tok = this.tok('block', name);\n      var len = captures[0].length - comment.length;\n      while (this.whitespaceRe.test(this.input.charAt(len - 1))) len--;\n      this.incrementColumn(len);\n      tok.mode = 'prepend';\n      this.tokens.push(this.tokEnd(tok));\n      this.consume(captures[0].length - comment.length);\n      this.incrementColumn(captures[0].length - comment.length - len);\n      return true;\n    }\n  },\n\n  /**\n   * Block append.\n   */\n\n  append: function() {\n    var captures;\n    if ((captures = /^(?:block +)?append +([^\\n]+)/.exec(this.input))) {\n      var name = captures[1].trim();\n      var comment = '';\n      if (name.indexOf('//') !== -1) {\n        comment =\n          '//' +\n          name\n            .split('//')\n            .slice(1)\n            .join('//');\n        name = name.split('//')[0].trim();\n      }\n      if (!name) return;\n      var tok = this.tok('block', name);\n      var len = captures[0].length - comment.length;\n      while (this.whitespaceRe.test(this.input.charAt(len - 1))) len--;\n      this.incrementColumn(len);\n      tok.mode = 'append';\n      this.tokens.push(this.tokEnd(tok));\n      this.consume(captures[0].length - comment.length);\n      this.incrementColumn(captures[0].length - comment.length - len);\n      return true;\n    }\n  },\n\n  /**\n   * Block.\n   */\n\n  block: function() {\n    var captures;\n    if ((captures = /^block +([^\\n]+)/.exec(this.input))) {\n      var name = captures[1].trim();\n      var comment = '';\n      if (name.indexOf('//') !== -1) {\n        comment =\n          '//' +\n          name\n            .split('//')\n            .slice(1)\n            .join('//');\n        name = name.split('//')[0].trim();\n      }\n      if (!name) return;\n      var tok = this.tok('block', name);\n      var len = captures[0].length - comment.length;\n      while (this.whitespaceRe.test(this.input.charAt(len - 1))) len--;\n      this.incrementColumn(len);\n      tok.mode = 'replace';\n      this.tokens.push(this.tokEnd(tok));\n      this.consume(captures[0].length - comment.length);\n      this.incrementColumn(captures[0].length - comment.length - len);\n      return true;\n    }\n  },\n\n  /**\n   * Mixin Block.\n   */\n\n  mixinBlock: function() {\n    var tok;\n    if ((tok = this.scanEndOfLine(/^block/, 'mixin-block'))) {\n      this.tokens.push(this.tokEnd(tok));\n      return true;\n    }\n  },\n\n  /**\n   * Yield.\n   */\n\n  yield: function() {\n    var tok = this.scanEndOfLine(/^yield/, 'yield');\n    if (tok) {\n      this.tokens.push(this.tokEnd(tok));\n      return true;\n    }\n  },\n\n  /**\n   * Include.\n   */\n\n  include: function() {\n    var tok = this.scan(/^include(?=:| |$|\\n)/, 'include');\n    if (tok) {\n      this.tokens.push(this.tokEnd(tok));\n      while (this.callLexerFunction('filter', {inInclude: true}));\n      if (!this.callLexerFunction('path')) {\n        if (/^[^ \\n]+/.test(this.input)) {\n          // if there is more text\n          this.fail();\n        } else {\n          // if not\n          this.error('NO_INCLUDE_PATH', 'missing path for include');\n        }\n      }\n      return true;\n    }\n    if (this.scan(/^include\\b/)) {\n      this.error('MALFORMED_INCLUDE', 'malformed include');\n    }\n  },\n\n  /**\n   * Path\n   */\n\n  path: function() {\n    var tok = this.scanEndOfLine(/^ ([^\\n]+)/, 'path');\n    if (tok && (tok.val = tok.val.trim())) {\n      this.tokens.push(this.tokEnd(tok));\n      return true;\n    }\n  },\n\n  /**\n   * Case.\n   */\n\n  case: function() {\n    var tok = this.scanEndOfLine(/^case +([^\\n]+)/, 'case');\n    if (tok) {\n      this.incrementColumn(-tok.val.length);\n      this.assertExpression(tok.val);\n      this.incrementColumn(tok.val.length);\n      this.tokens.push(this.tokEnd(tok));\n      return true;\n    }\n    if (this.scan(/^case\\b/)) {\n      this.error('NO_CASE_EXPRESSION', 'missing expression for case');\n    }\n  },\n\n  /**\n   * When.\n   */\n\n  when: function() {\n    var tok = this.scanEndOfLine(/^when +([^:\\n]+)/, 'when');\n    if (tok) {\n      var parser = characterParser(tok.val);\n      while (parser.isNesting() || parser.isString()) {\n        var rest = /:([^:\\n]+)/.exec(this.input);\n        if (!rest) break;\n\n        tok.val += rest[0];\n        this.consume(rest[0].length);\n        this.incrementColumn(rest[0].length);\n        parser = characterParser(tok.val);\n      }\n\n      this.incrementColumn(-tok.val.length);\n      this.assertExpression(tok.val);\n      this.incrementColumn(tok.val.length);\n      this.tokens.push(this.tokEnd(tok));\n      return true;\n    }\n    if (this.scan(/^when\\b/)) {\n      this.error('NO_WHEN_EXPRESSION', 'missing expression for when');\n    }\n  },\n\n  /**\n   * Default.\n   */\n\n  default: function() {\n    var tok = this.scanEndOfLine(/^default/, 'default');\n    if (tok) {\n      this.tokens.push(this.tokEnd(tok));\n      return true;\n    }\n    if (this.scan(/^default\\b/)) {\n      this.error(\n        'DEFAULT_WITH_EXPRESSION',\n        'default should not have an expression'\n      );\n    }\n  },\n\n  /**\n   * Call mixin.\n   */\n\n  call: function() {\n    var tok, captures, increment;\n    if ((captures = /^\\+(\\s*)(([-\\w]+)|(#\\{))/.exec(this.input))) {\n      // try to consume simple or interpolated call\n      if (captures[3]) {\n        // simple call\n        increment = captures[0].length;\n        this.consume(increment);\n        tok = this.tok('call', captures[3]);\n      } else {\n        // interpolated call\n        var match = this.bracketExpression(2 + captures[1].length);\n        increment = match.end + 1;\n        this.consume(increment);\n        this.assertExpression(match.src);\n        tok = this.tok('call', '#{' + match.src + '}');\n      }\n\n      this.incrementColumn(increment);\n\n      tok.args = null;\n      // Check for args (not attributes)\n      if ((captures = /^ *\\(/.exec(this.input))) {\n        var range = this.bracketExpression(captures[0].length - 1);\n        if (!/^\\s*[-\\w]+ *=/.test(range.src)) {\n          // not attributes\n          this.incrementColumn(1);\n          this.consume(range.end + 1);\n          tok.args = range.src;\n          this.assertExpression('[' + tok.args + ']');\n          for (var i = 0; i <= tok.args.length; i++) {\n            if (tok.args[i] === '\\n') {\n              this.incrementLine(1);\n            } else {\n              this.incrementColumn(1);\n            }\n          }\n        }\n      }\n      this.tokens.push(this.tokEnd(tok));\n      return true;\n    }\n  },\n\n  /**\n   * Mixin.\n   */\n\n  mixin: function() {\n    var captures;\n    if ((captures = /^mixin +([-\\w]+)(?: *\\((.*)\\))? */.exec(this.input))) {\n      this.consume(captures[0].length);\n      var tok = this.tok('mixin', captures[1]);\n      tok.args = captures[2] || null;\n      this.incrementColumn(captures[0].length);\n      this.tokens.push(this.tokEnd(tok));\n      return true;\n    }\n  },\n\n  /**\n   * Conditional.\n   */\n\n  conditional: function() {\n    var captures;\n    if ((captures = /^(if|unless|else if|else)\\b([^\\n]*)/.exec(this.input))) {\n      this.consume(captures[0].length);\n      var type = captures[1].replace(/ /g, '-');\n      var js = captures[2] && captures[2].trim();\n      // type can be \"if\", \"else-if\" and \"else\"\n      var tok = this.tok(type, js);\n      this.incrementColumn(captures[0].length - js.length);\n\n      switch (type) {\n        case 'if':\n        case 'else-if':\n          this.assertExpression(js);\n          break;\n        case 'unless':\n          this.assertExpression(js);\n          tok.val = '!(' + js + ')';\n          tok.type = 'if';\n          break;\n        case 'else':\n          if (js) {\n            this.error(\n              'ELSE_CONDITION',\n              '`else` cannot have a condition, perhaps you meant `else if`'\n            );\n          }\n          break;\n      }\n      this.incrementColumn(js.length);\n      this.tokens.push(this.tokEnd(tok));\n      return true;\n    }\n  },\n\n  /**\n   * While.\n   */\n\n  while: function() {\n    var captures, tok;\n    if ((captures = /^while +([^\\n]+)/.exec(this.input))) {\n      this.consume(captures[0].length);\n      this.assertExpression(captures[1]);\n      tok = this.tok('while', captures[1]);\n      this.incrementColumn(captures[0].length);\n      this.tokens.push(this.tokEnd(tok));\n      return true;\n    }\n    if (this.scan(/^while\\b/)) {\n      this.error('NO_WHILE_EXPRESSION', 'missing expression for while');\n    }\n  },\n\n  /**\n   * Each.\n   */\n\n  each: function() {\n    var captures;\n    if (\n      (captures = /^(?:each|for) +([a-zA-Z_$][\\w$]*)(?: *, *([a-zA-Z_$][\\w$]*))? * in *([^\\n]+)/.exec(\n        this.input\n      ))\n    ) {\n      this.consume(captures[0].length);\n      var tok = this.tok('each', captures[1]);\n      tok.key = captures[2] || null;\n      this.incrementColumn(captures[0].length - captures[3].length);\n      this.assertExpression(captures[3]);\n      tok.code = captures[3];\n      this.incrementColumn(captures[3].length);\n      this.tokens.push(this.tokEnd(tok));\n      return true;\n    }\n    const name = /^each\\b/.exec(this.input) ? 'each' : 'for';\n    if (this.scan(/^(?:each|for)\\b/)) {\n      this.error(\n        'MALFORMED_EACH',\n        'This `' +\n          name +\n          '` has a syntax error. `' +\n          name +\n          '` statements should be of the form: `' +\n          name +\n          ' VARIABLE_NAME of JS_EXPRESSION`'\n      );\n    }\n    if (\n      (captures = /^- *(?:each|for) +([a-zA-Z_$][\\w$]*)(?: *, *([a-zA-Z_$][\\w$]*))? +in +([^\\n]+)/.exec(\n        this.input\n      ))\n    ) {\n      this.error(\n        'MALFORMED_EACH',\n        'Pug each and for should no longer be prefixed with a dash (\"-\"). They are pug keywords and not part of JavaScript.'\n      );\n    }\n  },\n\n  /**\n   * EachOf.\n   */\n\n  eachOf: function() {\n    var captures;\n    if ((captures = /^(?:each|for) (.*) of *([^\\n]+)/.exec(this.input))) {\n      this.consume(captures[0].length);\n      var tok = this.tok('eachOf', captures[1]);\n      tok.value = captures[1];\n      this.incrementColumn(captures[0].length - captures[2].length);\n      this.assertExpression(captures[2]);\n      tok.code = captures[2];\n      this.incrementColumn(captures[2].length);\n      this.tokens.push(this.tokEnd(tok));\n\n      if (\n        !(\n          /^[a-zA-Z_$][\\w$]*$/.test(tok.value.trim()) ||\n          /^\\[ *[a-zA-Z_$][\\w$]* *\\, *[a-zA-Z_$][\\w$]* *\\]$/.test(\n            tok.value.trim()\n          )\n        )\n      ) {\n        this.error(\n          'MALFORMED_EACH_OF_LVAL',\n          'The value variable for each must either be a valid identifier (e.g. `item`) or a pair of identifiers in square brackets (e.g. `[key, value]`).'\n        );\n      }\n\n      return true;\n    }\n    if (\n      (captures = /^- *(?:each|for) +([a-zA-Z_$][\\w$]*)(?: *, *([a-zA-Z_$][\\w$]*))? +of +([^\\n]+)/.exec(\n        this.input\n      ))\n    ) {\n      this.error(\n        'MALFORMED_EACH',\n        'Pug each and for should not be prefixed with a dash (\"-\"). They are pug keywords and not part of JavaScript.'\n      );\n    }\n  },\n\n  /**\n   * Code.\n   */\n\n  code: function() {\n    var captures;\n    if ((captures = /^(!?=|-)[ \\t]*([^\\n]+)/.exec(this.input))) {\n      var flags = captures[1];\n      var code = captures[2];\n      var shortened = 0;\n      if (this.interpolated) {\n        var parsed;\n        try {\n          parsed = characterParser.parseUntil(code, ']');\n        } catch (err) {\n          if (err.index !== undefined) {\n            this.incrementColumn(captures[0].length - code.length + err.index);\n          }\n          if (err.code === 'CHARACTER_PARSER:END_OF_STRING_REACHED') {\n            this.error(\n              'NO_END_BRACKET',\n              'End of line was reached with no closing bracket for interpolation.'\n            );\n          } else if (err.code === 'CHARACTER_PARSER:MISMATCHED_BRACKET') {\n            this.error('BRACKET_MISMATCH', err.message);\n          } else {\n            throw err;\n          }\n        }\n        shortened = code.length - parsed.end;\n        code = parsed.src;\n      }\n      var consumed = captures[0].length - shortened;\n      this.consume(consumed);\n      var tok = this.tok('code', code);\n      tok.mustEscape = flags.charAt(0) === '=';\n      tok.buffer = flags.charAt(0) === '=' || flags.charAt(1) === '=';\n\n      // p #[!=    abc] hey\n      //     ^              original colno\n      //     -------------- captures[0]\n      //           -------- captures[2]\n      //     ------         captures[0] - captures[2]\n      //           ^        after colno\n\n      // =   abc\n      // ^                  original colno\n      // -------            captures[0]\n      //     ---            captures[2]\n      // ----               captures[0] - captures[2]\n      //     ^              after colno\n      this.incrementColumn(captures[0].length - captures[2].length);\n      if (tok.buffer) this.assertExpression(code);\n      this.tokens.push(tok);\n\n      // p #[!=    abc] hey\n      //           ^        original colno\n      //              ----- shortened\n      //           ---      code\n      //              ^     after colno\n\n      // =   abc\n      //     ^              original colno\n      //                    shortened\n      //     ---            code\n      //        ^           after colno\n      this.incrementColumn(code.length);\n      this.tokEnd(tok);\n      return true;\n    }\n  },\n\n  /**\n   * Block code.\n   */\n  blockCode: function() {\n    var tok;\n    if ((tok = this.scanEndOfLine(/^-/, 'blockcode'))) {\n      this.tokens.push(this.tokEnd(tok));\n      this.interpolationAllowed = false;\n      this.callLexerFunction('pipelessText');\n      return true;\n    }\n  },\n\n  /**\n   * Attribute Name.\n   */\n  attribute: function(str) {\n    var quote = '';\n    var quoteRe = /['\"]/;\n    var key = '';\n    var i;\n\n    // consume all whitespace before the key\n    for (i = 0; i < str.length; i++) {\n      if (!this.whitespaceRe.test(str[i])) break;\n      if (str[i] === '\\n') {\n        this.incrementLine(1);\n      } else {\n        this.incrementColumn(1);\n      }\n    }\n\n    if (i === str.length) {\n      return '';\n    }\n\n    var tok = this.tok('attribute');\n\n    // quote?\n    if (quoteRe.test(str[i])) {\n      quote = str[i];\n      this.incrementColumn(1);\n      i++;\n    }\n\n    // start looping through the key\n    for (; i < str.length; i++) {\n      if (quote) {\n        if (str[i] === quote) {\n          this.incrementColumn(1);\n          i++;\n          break;\n        }\n      } else {\n        if (\n          this.whitespaceRe.test(str[i]) ||\n          str[i] === '!' ||\n          str[i] === '=' ||\n          str[i] === ','\n        ) {\n          break;\n        }\n      }\n\n      key += str[i];\n\n      if (str[i] === '\\n') {\n        this.incrementLine(1);\n      } else {\n        this.incrementColumn(1);\n      }\n    }\n\n    tok.name = key;\n\n    var valueResponse = this.attributeValue(str.substr(i));\n\n    if (valueResponse.val) {\n      tok.val = valueResponse.val;\n      tok.mustEscape = valueResponse.mustEscape;\n    } else {\n      // was a boolean attribute (ex: `input(disabled)`)\n      tok.val = true;\n      tok.mustEscape = true;\n    }\n\n    str = valueResponse.remainingSource;\n\n    this.tokens.push(this.tokEnd(tok));\n\n    for (i = 0; i < str.length; i++) {\n      if (!this.whitespaceRe.test(str[i])) {\n        break;\n      }\n      if (str[i] === '\\n') {\n        this.incrementLine(1);\n      } else {\n        this.incrementColumn(1);\n      }\n    }\n\n    if (str[i] === ',') {\n      this.incrementColumn(1);\n      i++;\n    }\n\n    return str.substr(i);\n  },\n\n  /**\n   * Attribute Value.\n   */\n  attributeValue: function(str) {\n    var quoteRe = /['\"]/;\n    var val = '';\n    var done, i, x;\n    var escapeAttr = true;\n    var state = characterParser.defaultState();\n    var col = this.colno;\n    var line = this.lineno;\n\n    // consume all whitespace before the equals sign\n    for (i = 0; i < str.length; i++) {\n      if (!this.whitespaceRe.test(str[i])) break;\n      if (str[i] === '\\n') {\n        line++;\n        col = 1;\n      } else {\n        col++;\n      }\n    }\n\n    if (i === str.length) {\n      return {remainingSource: str};\n    }\n\n    if (str[i] === '!') {\n      escapeAttr = false;\n      col++;\n      i++;\n      if (str[i] !== '=')\n        this.error(\n          'INVALID_KEY_CHARACTER',\n          'Unexpected character ' + str[i] + ' expected `=`'\n        );\n    }\n\n    if (str[i] !== '=') {\n      // check for anti-pattern `div(\"foo\"bar)`\n      if (i === 0 && str && !this.whitespaceRe.test(str[0]) && str[0] !== ',') {\n        this.error(\n          'INVALID_KEY_CHARACTER',\n          'Unexpected character ' + str[0] + ' expected `=`'\n        );\n      } else {\n        return {remainingSource: str};\n      }\n    }\n\n    this.lineno = line;\n    this.colno = col + 1;\n    i++;\n\n    // consume all whitespace before the value\n    for (; i < str.length; i++) {\n      if (!this.whitespaceRe.test(str[i])) break;\n      if (str[i] === '\\n') {\n        this.incrementLine(1);\n      } else {\n        this.incrementColumn(1);\n      }\n    }\n\n    line = this.lineno;\n    col = this.colno;\n\n    // start looping through the value\n    for (; i < str.length; i++) {\n      // if the character is in a string or in parentheses/brackets/braces\n      if (!(state.isNesting() || state.isString())) {\n        if (this.whitespaceRe.test(str[i])) {\n          done = false;\n\n          // find the first non-whitespace character\n          for (x = i; x < str.length; x++) {\n            if (!this.whitespaceRe.test(str[x])) {\n              // if it is a JavaScript punctuator, then assume that it is\n              // a part of the value\n              const isNotPunctuator = !characterParser.isPunctuator(str[x]);\n              const isQuote = quoteRe.test(str[x]);\n              const isColon = str[x] === ':';\n              const isSpreadOperator =\n                str[x] + str[x + 1] + str[x + 2] === '...';\n              if (\n                (isNotPunctuator || isQuote || isColon || isSpreadOperator) &&\n                this.assertExpression(val, true)\n              ) {\n                done = true;\n              }\n              break;\n            }\n          }\n\n          // if everything else is whitespace, return now so last attribute\n          // does not include trailing whitespace\n          if (done || x === str.length) {\n            break;\n          }\n        }\n\n        // if there's no whitespace and the character is not ',', the\n        // attribute did not end.\n        if (str[i] === ',' && this.assertExpression(val, true)) {\n          break;\n        }\n      }\n\n      state = characterParser.parseChar(str[i], state);\n      val += str[i];\n\n      if (str[i] === '\\n') {\n        line++;\n        col = 1;\n      } else {\n        col++;\n      }\n    }\n\n    this.assertExpression(val);\n\n    this.lineno = line;\n    this.colno = col;\n\n    return {val: val, mustEscape: escapeAttr, remainingSource: str.substr(i)};\n  },\n\n  /**\n   * Attributes.\n   */\n\n  attrs: function() {\n    var tok;\n\n    if ('(' == this.input.charAt(0)) {\n      tok = this.tok('start-attributes');\n      var index = this.bracketExpression().end;\n      var str = this.input.substr(1, index - 1);\n\n      this.incrementColumn(1);\n      this.tokens.push(this.tokEnd(tok));\n      this.assertNestingCorrect(str);\n      this.consume(index + 1);\n\n      while (str) {\n        str = this.attribute(str);\n      }\n\n      tok = this.tok('end-attributes');\n      this.incrementColumn(1);\n      this.tokens.push(this.tokEnd(tok));\n      return true;\n    }\n  },\n\n  /**\n   * &attributes block\n   */\n  attributesBlock: function() {\n    if (/^&attributes\\b/.test(this.input)) {\n      var consumed = 11;\n      this.consume(consumed);\n      var tok = this.tok('&attributes');\n      this.incrementColumn(consumed);\n      var args = this.bracketExpression();\n      consumed = args.end + 1;\n      this.consume(consumed);\n      tok.val = args.src;\n      this.incrementColumn(consumed);\n      this.tokens.push(this.tokEnd(tok));\n      return true;\n    }\n  },\n\n  /**\n   * Indent | Outdent | Newline.\n   */\n\n  indent: function() {\n    var captures = this.scanIndentation();\n    var tok;\n\n    if (captures) {\n      var indents = captures[1].length;\n\n      this.incrementLine(1);\n      this.consume(indents + 1);\n\n      if (' ' == this.input[0] || '\\t' == this.input[0]) {\n        this.error(\n          'INVALID_INDENTATION',\n          'Invalid indentation, you can use tabs or spaces but not both'\n        );\n      }\n\n      // blank line\n      if ('\\n' == this.input[0]) {\n        this.interpolationAllowed = true;\n        return this.tokEnd(this.tok('newline'));\n      }\n\n      // outdent\n      if (indents < this.indentStack[0]) {\n        var outdent_count = 0;\n        while (this.indentStack[0] > indents) {\n          if (this.indentStack[1] < indents) {\n            this.error(\n              'INCONSISTENT_INDENTATION',\n              'Inconsistent indentation. Expecting either ' +\n                this.indentStack[1] +\n                ' or ' +\n                this.indentStack[0] +\n                ' spaces/tabs.'\n            );\n          }\n          outdent_count++;\n          this.indentStack.shift();\n        }\n        while (outdent_count--) {\n          this.colno = 1;\n          tok = this.tok('outdent');\n          this.colno = this.indentStack[0] + 1;\n          this.tokens.push(this.tokEnd(tok));\n        }\n        // indent\n      } else if (indents && indents != this.indentStack[0]) {\n        tok = this.tok('indent', indents);\n        this.colno = 1 + indents;\n        this.tokens.push(this.tokEnd(tok));\n        this.indentStack.unshift(indents);\n        // newline\n      } else {\n        tok = this.tok('newline');\n        this.colno = 1 + Math.min(this.indentStack[0] || 0, indents);\n        this.tokens.push(this.tokEnd(tok));\n      }\n\n      this.interpolationAllowed = true;\n      return true;\n    }\n  },\n\n  pipelessText: function pipelessText(indents) {\n    while (this.callLexerFunction('blank'));\n\n    var captures = this.scanIndentation();\n\n    indents = indents || (captures && captures[1].length);\n    if (indents > this.indentStack[0]) {\n      this.tokens.push(this.tokEnd(this.tok('start-pipeless-text')));\n      var tokens = [];\n      var token_indent = [];\n      var isMatch;\n      // Index in this.input. Can't use this.consume because we might need to\n      // retry lexing the block.\n      var stringPtr = 0;\n      do {\n        // text has `\\n` as a prefix\n        var i = this.input.substr(stringPtr + 1).indexOf('\\n');\n        if (-1 == i) i = this.input.length - stringPtr - 1;\n        var str = this.input.substr(stringPtr + 1, i);\n        var lineCaptures = this.indentRe.exec('\\n' + str);\n        var lineIndents = lineCaptures && lineCaptures[1].length;\n        isMatch = lineIndents >= indents;\n        token_indent.push(isMatch);\n        isMatch = isMatch || !str.trim();\n        if (isMatch) {\n          // consume test along with `\\n` prefix if match\n          stringPtr += str.length + 1;\n          tokens.push(str.substr(indents));\n        } else if (lineIndents > this.indentStack[0]) {\n          // line is indented less than the first line but is still indented\n          // need to retry lexing the text block\n          this.tokens.pop();\n          return pipelessText.call(this, lineCaptures[1].length);\n        }\n      } while (this.input.length - stringPtr && isMatch);\n      this.consume(stringPtr);\n      while (this.input.length === 0 && tokens[tokens.length - 1] === '')\n        tokens.pop();\n      tokens.forEach(\n        function(token, i) {\n          var tok;\n          this.incrementLine(1);\n          if (i !== 0) tok = this.tok('newline');\n          if (token_indent[i]) this.incrementColumn(indents);\n          if (tok) this.tokens.push(this.tokEnd(tok));\n          this.addText('text', token);\n        }.bind(this)\n      );\n      this.tokens.push(this.tokEnd(this.tok('end-pipeless-text')));\n      return true;\n    }\n  },\n\n  /**\n   * Slash.\n   */\n\n  slash: function() {\n    var tok = this.scan(/^\\//, 'slash');\n    if (tok) {\n      this.tokens.push(this.tokEnd(tok));\n      return true;\n    }\n  },\n\n  /**\n   * ':'\n   */\n\n  colon: function() {\n    var tok = this.scan(/^: +/, ':');\n    if (tok) {\n      this.tokens.push(this.tokEnd(tok));\n      return true;\n    }\n  },\n\n  fail: function() {\n    this.error(\n      'UNEXPECTED_TEXT',\n      'unexpected text \"' + this.input.substr(0, 5) + '\"'\n    );\n  },\n\n  callLexerFunction: function(func) {\n    var rest = [];\n    for (var i = 1; i < arguments.length; i++) {\n      rest.push(arguments[i]);\n    }\n    var pluginArgs = [this].concat(rest);\n    for (var i = 0; i < this.plugins.length; i++) {\n      var plugin = this.plugins[i];\n      if (plugin[func] && plugin[func].apply(plugin, pluginArgs)) {\n        return true;\n      }\n    }\n    return this[func].apply(this, rest);\n  },\n\n  /**\n   * Move to the next token\n   *\n   * @api private\n   */\n\n  advance: function() {\n    return (\n      this.callLexerFunction('blank') ||\n      this.callLexerFunction('eos') ||\n      this.callLexerFunction('endInterpolation') ||\n      this.callLexerFunction('yield') ||\n      this.callLexerFunction('doctype') ||\n      this.callLexerFunction('interpolation') ||\n      this.callLexerFunction('case') ||\n      this.callLexerFunction('when') ||\n      this.callLexerFunction('default') ||\n      this.callLexerFunction('extends') ||\n      this.callLexerFunction('append') ||\n      this.callLexerFunction('prepend') ||\n      this.callLexerFunction('block') ||\n      this.callLexerFunction('mixinBlock') ||\n      this.callLexerFunction('include') ||\n      this.callLexerFunction('mixin') ||\n      this.callLexerFunction('call') ||\n      this.callLexerFunction('conditional') ||\n      this.callLexerFunction('eachOf') ||\n      this.callLexerFunction('each') ||\n      this.callLexerFunction('while') ||\n      this.callLexerFunction('tag') ||\n      this.callLexerFunction('filter') ||\n      this.callLexerFunction('blockCode') ||\n      this.callLexerFunction('code') ||\n      this.callLexerFunction('id') ||\n      this.callLexerFunction('dot') ||\n      this.callLexerFunction('className') ||\n      this.callLexerFunction('attrs') ||\n      this.callLexerFunction('attributesBlock') ||\n      this.callLexerFunction('indent') ||\n      this.callLexerFunction('text') ||\n      this.callLexerFunction('textHtml') ||\n      this.callLexerFunction('comment') ||\n      this.callLexerFunction('slash') ||\n      this.callLexerFunction('colon') ||\n      this.fail()\n    );\n  },\n\n  /**\n   * Return an array of tokens for the current file\n   *\n   * @returns {Array.<Token>}\n   * @api public\n   */\n  getTokens: function() {\n    while (!this.ended) {\n      this.callLexerFunction('advance');\n    }\n    return this.tokens;\n  },\n};\n"]},"metadata":{},"sourceType":"script"}